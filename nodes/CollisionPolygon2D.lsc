# CollisionPolygon2D - 2D polygon collision shape
# Provides complex polygon collision detection for physics bodies
extends Node2D

# Polygon Properties
export_group("Polygon")
export var polygon: Array = [[0.0, 0.0], [32.0, 0.0], [32.0, 32.0], [0.0, 32.0]]  # Polygon vertices
export var disabled: bool = false  # Whether collision is disabled

# Build Mode
export_group("Build Mode")
export var build_mode: String = "solids"  # "solids", "segments"

# One-way Collision
export_group("One-way Collision")
export var one_way_collision: bool = false  # Enable one-way collision
export var one_way_collision_margin: float = 1.0  # Margin for one-way collision

# Debug Properties
export_group("Debug")
export var debug_color: Color = Color(0.0, 0.6, 0.7, 0.5)  # Debug visualization color

# Internal properties
var _physics_body: Node2D = null  # Reference to parent physics body
var _polygon_valid: bool = true  # Whether polygon is valid

# Called when the node enters the scene tree
func _ready():
    # Find parent physics body
    _physics_body = get_parent()
    
    # Validate parent is a physics body
    if not _is_physics_body(_physics_body):
        print("Warning: CollisionPolygon2D should be child of physics body (RigidBody2D, StaticBody2D, KinematicBody2D, or Area2D)")
    
    # Validate polygon
    _validate_polygon()

# Called every frame
func _process(delta: float):
    # Update collision polygon if properties changed
    _update_collision_polygon()

# Check if node is a physics body
func _is_physics_body(node: Node) -> bool:
    if not node:
        return false
    
    var node_type = node.get("type")
    return node_type in ["RigidBody2D", "StaticBody2D", "KinematicBody2D", "Area2D"]

# Validate polygon structure and geometry
func _validate_polygon() -> bool:
    if not polygon or polygon.size() < 3:
        _polygon_valid = false
        print("Warning: Polygon must have at least 3 vertices")
        return false
    
    # Check for valid vertex format
    for vertex in polygon:
        if not vertex is Array or vertex.size() != 2:
            _polygon_valid = false
            print("Warning: Polygon vertices must be [x, y] arrays")
            return false
    
    # Check for self-intersection (basic check)
    if not _is_polygon_simple():
        print("Warning: Polygon may be self-intersecting")
    
    _polygon_valid = true
    return true

# Check if polygon is simple (no self-intersections)
func _is_polygon_simple() -> bool:
    # Basic implementation - could be enhanced
    var vertex_count = polygon.size()
    if vertex_count < 4:
        return true  # Triangle is always simple
    
    # For now, assume polygon is simple
    # A full implementation would check all edge pairs for intersections
    return true

# Update collision polygon based on current properties
func _update_collision_polygon():
    if not _physics_body or not _polygon_valid:
        return
    
    # Implementation will be handled by physics system
    pass

# Get polygon bounds for debug rendering
func get_polygon_bounds() -> Rect2:
    if not polygon or polygon.size() == 0:
        return Rect2(Vector2.ZERO, Vector2(32, 32))
    
    var min_x = polygon[0][0]
    var max_x = polygon[0][0]
    var min_y = polygon[0][1]
    var max_y = polygon[0][1]
    
    for vertex in polygon:
        min_x = min(min_x, vertex[0])
        max_x = max(max_x, vertex[0])
        min_y = min(min_y, vertex[1])
        max_y = max(max_y, vertex[1])
    
    return Rect2(Vector2(min_x, min_y), Vector2(max_x - min_x, max_y - min_y))

# Set polygon vertices
func set_polygon(new_polygon: Array):
    polygon = new_polygon
    if _validate_polygon():
        _update_collision_polygon()
        emit_signal("polygon_changed", polygon)

# Add vertex to polygon
func add_vertex(vertex: Vector2, index: int = -1):
    var vertex_array = [vertex.x, vertex.y]
    
    if index < 0 or index >= polygon.size():
        polygon.append(vertex_array)
    else:
        polygon.insert(index, vertex_array)
    
    if _validate_polygon():
        _update_collision_polygon()
        emit_signal("polygon_changed", polygon)

# Remove vertex from polygon
func remove_vertex(index: int):
    if index >= 0 and index < polygon.size():
        polygon.remove(index)
        
        if _validate_polygon():
            _update_collision_polygon()
            emit_signal("polygon_changed", polygon)

# Set vertex position
func set_vertex(index: int, vertex: Vector2):
    if index >= 0 and index < polygon.size():
        polygon[index] = [vertex.x, vertex.y]
        
        if _validate_polygon():
            _update_collision_polygon()
            emit_signal("polygon_changed", polygon)

# Get vertex position
func get_vertex(index: int) -> Vector2:
    if index >= 0 and index < polygon.size():
        var vertex = polygon[index]
        return Vector2(vertex[0], vertex[1])
    return Vector2.ZERO

# Get vertex count
func get_vertex_count() -> int:
    return polygon.size()

# Clear all vertices
func clear_polygon():
    polygon.clear()
    _polygon_valid = false
    _update_collision_polygon()
    emit_signal("polygon_changed", polygon)

# Create rectangle polygon
func create_rectangle(size: Vector2, center: Vector2 = Vector2.ZERO):
    var half_size = size / 2
    polygon = [
        [center.x - half_size.x, center.y - half_size.y],  # Top-left
        [center.x + half_size.x, center.y - half_size.y],  # Top-right
        [center.x + half_size.x, center.y + half_size.y],  # Bottom-right
        [center.x - half_size.x, center.y + half_size.y]   # Bottom-left
    ]
    
    if _validate_polygon():
        _update_collision_polygon()
        emit_signal("polygon_changed", polygon)

# Create circle polygon (approximation)
func create_circle(radius: float, segments: int = 16, center: Vector2 = Vector2.ZERO):
    polygon.clear()
    
    for i in range(segments):
        var angle = (i * 2.0 * PI) / segments
        var x = center.x + cos(angle) * radius
        var y = center.y + sin(angle) * radius
        polygon.append([x, y])
    
    if _validate_polygon():
        _update_collision_polygon()
        emit_signal("polygon_changed", polygon)

# Enable/disable collision
func set_disabled(is_disabled: bool):
    disabled = is_disabled
    _update_collision_polygon()

# Set build mode
func set_build_mode(mode: String):
    if mode in ["solids", "segments"]:
        build_mode = mode
        _update_collision_polygon()

# Set one-way collision
func set_one_way_collision(enabled: bool, margin: float = 1.0):
    one_way_collision = enabled
    one_way_collision_margin = margin
    _update_collision_polygon()

# Get collision polygon data for physics system
func get_collision_data() -> Dictionary:
    return {
        "polygon": polygon,
        "disabled": disabled,
        "build_mode": build_mode,
        "one_way_collision": one_way_collision,
        "one_way_collision_margin": one_way_collision_margin,
        "debug_color": debug_color,
        "valid": _polygon_valid
    }

# Check if point is inside polygon
func is_point_inside(point: Vector2) -> bool:
    if not _polygon_valid:
        return false
    
    # Ray casting algorithm
    var vertex_count = polygon.size()
    var inside = false
    
    var j = vertex_count - 1
    for i in range(vertex_count):
        var vi = Vector2(polygon[i][0], polygon[i][1])
        var vj = Vector2(polygon[j][0], polygon[j][1])
        
        if ((vi.y > point.y) != (vj.y > point.y)) and (point.x < (vj.x - vi.x) * (point.y - vi.y) / (vj.y - vi.y) + vi.x):
            inside = not inside
        
        j = i
    
    return inside

# Signals
signal polygon_changed(new_polygon)  # Emitted when polygon vertices change
signal properties_changed  # Emitted when polygon properties change
