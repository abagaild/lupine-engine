# AudioStreamPlayer2D Node - 2D positional audio player with distance attenuation
# Equivalent to Godot's AudioStreamPlayer2D with full spatial audio capabilities
extends Node2D

# Audio Properties (inherited from AudioStreamPlayer)
export_group("Audio")
export var stream: path = ""  # AudioStream resource to play (uses file browser)
export var volume_db: float = 0.0  # Volume in decibels (-80 to 24)
export var pitch_scale: float = 1.0  # Pitch multiplier (0.01 to 4.0)
export var playing: bool = false  # Whether audio is currently playing
export var autoplay: bool = false  # Start playing when node enters tree
export var stream_paused: bool = false  # Whether playback is paused
export var loop: bool = false  # Whether to loop the audio

# Bus Properties
export_group("Bus")
export var bus: String = "Master"  # Audio bus name

# 2D Spatial Properties
export_group("2D Spatial")
export var attenuation: float = 1.0  # Distance attenuation curve (0.0 to 4.0)
export var max_distance: float = 2000.0  # Maximum audible distance
export var area_mask: int = 1  # Area2D collision mask for audio occlusion

# Doppler Effect
export_group("Doppler")
export var doppler_tracking: String = "disabled"  # Doppler effect mode

# Internal state (not exported)
var _audio_source_id: String = ""
var _playback_position: float = 0.0
var _last_position: Vector2 = Vector2.ZERO

# Doppler tracking constants
const DOPPLER_DISABLED = "disabled"
const DOPPLER_IDLE_STEP = "idle_step"
const DOPPLER_PHYSICS_STEP = "physics_step"

# Called when the node enters the scene tree for the first time
func _ready():
    super._ready()
    
    # Generate unique audio source ID
    _audio_source_id = name + "_" + str(get_instance_id())
    
    # Initialize position tracking
    _last_position = global_position
    
    # Auto-play if enabled
    if autoplay and stream:
        play()

# Called every frame. 'delta' is the elapsed time since the previous frame
func _process(delta: float):
    # Update playback position if playing
    if playing and not stream_paused:
        _playback_position += delta
    
    # Update spatial audio properties
    if playing:
        _update_spatial_audio()
    
    # Update Doppler effect if enabled
    if doppler_tracking == DOPPLER_IDLE_STEP:
        _update_doppler_effect(delta)

# Called during physics step
func _physics_process(delta: float):
    # Update Doppler effect if enabled for physics step
    if doppler_tracking == DOPPLER_PHYSICS_STEP:
        _update_doppler_effect(delta)

# Play the audio stream
func play(from_position: float = 0.0):
    if not stream:
        print("Warning: No audio stream assigned to AudioStreamPlayer2D")
        return
    
    _playback_position = from_position
    playing = true
    stream_paused = false
    
    # Call engine audio system with spatial properties
    _play_spatial_audio_stream()
    
    emit_signal("playback_started")

# Stop the audio stream
func stop():
    if playing:
        playing = false
        stream_paused = false
        _playback_position = 0.0
        
        # Call engine audio system
        _stop_audio_stream()
        
        emit_signal("playback_stopped")

# Pause the audio stream
func pause():
    if playing and not stream_paused:
        stream_paused = true
        
        # Call engine audio system
        _pause_audio_stream()
        
        emit_signal("playback_paused")

# Resume the audio stream
func resume():
    if playing and stream_paused:
        stream_paused = false
        
        # Call engine audio system
        _resume_audio_stream()
        
        emit_signal("playback_resumed")

# Set the audio stream
func set_stream(new_stream: AudioStream):
    var was_playing = playing
    
    if was_playing:
        stop()
    
    stream = new_stream
    
    if was_playing and stream:
        play()
    
    emit_signal("stream_changed", stream)

# Get the audio stream
func get_stream() -> AudioStream:
    return stream

# Set volume in decibels
func set_volume_db(db: float):
    volume_db = clamp(db, -80.0, 24.0)
    
    # Update audio system if playing
    if playing:
        _update_spatial_audio()
    
    emit_signal("volume_changed", volume_db)

# Get volume in decibels
func get_volume_db() -> float:
    return volume_db

# Set volume as linear (0.0 to 1.0+)
func set_volume_linear(linear: float):
    # Convert linear to decibels
    if linear <= 0.0:
        set_volume_db(-80.0)
    else:
        set_volume_db(20.0 * log(linear) / log(10.0))

# Get volume as linear (0.0 to 1.0+)
func get_volume_linear() -> float:
    if volume_db <= -80.0:
        return 0.0
    return pow(10.0, volume_db / 20.0)

# Set pitch scale
func set_pitch_scale(scale: float):
    pitch_scale = clamp(scale, 0.01, 4.0)
    
    # Update audio system if playing
    if playing:
        _update_spatial_audio()
    
    emit_signal("pitch_changed", pitch_scale)

# Get pitch scale
func get_pitch_scale() -> float:
    return pitch_scale

# Set attenuation curve
func set_attenuation(curve: float):
    attenuation = clamp(curve, 0.0, 4.0)
    
    # Update audio system if playing
    if playing:
        _update_spatial_audio()
    
    emit_signal("attenuation_changed", attenuation)

# Get attenuation curve
func get_attenuation() -> float:
    return attenuation

# Set maximum audible distance
func set_max_distance(distance: float):
    max_distance = max(0.0, distance)
    
    # Update audio system if playing
    if playing:
        _update_spatial_audio()
    
    emit_signal("max_distance_changed", max_distance)

# Get maximum audible distance
func get_max_distance() -> float:
    return max_distance

# Set area mask for occlusion
func set_area_mask(mask: int):
    area_mask = mask
    emit_signal("area_mask_changed", area_mask)

# Get area mask
func get_area_mask() -> int:
    return area_mask

# Set Doppler tracking mode
func set_doppler_tracking(mode: String):
    if is_valid_doppler_mode(mode):
        doppler_tracking = mode
        emit_signal("doppler_tracking_changed", doppler_tracking)
    else:
        print("Warning: Invalid Doppler tracking mode: " + mode)

# Get Doppler tracking mode
func get_doppler_tracking() -> String:
    return doppler_tracking

# Check if Doppler mode is valid
func is_valid_doppler_mode(mode: String) -> bool:
    return mode in [DOPPLER_DISABLED, DOPPLER_IDLE_STEP, DOPPLER_PHYSICS_STEP]

# Get current playback position in seconds
func get_playback_position() -> float:
    return _playback_position

# Seek to specific position in seconds
func seek(position: float):
    if stream:
        _playback_position = clamp(position, 0.0, get_stream_length())
        
        if playing:
            # Restart playback from new position
            _play_spatial_audio_stream()

# Get stream length in seconds
func get_stream_length() -> float:
    if stream:
        return stream.get_length() if stream.has_method("get_length") else 0.0
    return 0.0

# Check if stream has finished playing
func is_finished() -> bool:
    if not stream or not playing:
        return true
    
    return _playback_position >= get_stream_length()

# Get distance to listener
func get_distance_to_listener() -> float:
    # This would get the listener position from the audio system
    # For now, assume listener is at origin
    return global_position.length()

# Calculate volume based on distance
func get_distance_volume() -> float:
    var distance = get_distance_to_listener()
    
    if distance >= max_distance:
        return 0.0
    
    if distance <= 0.0:
        return 1.0
    
    # Apply attenuation curve
    var normalized_distance = distance / max_distance
    return pow(1.0 - normalized_distance, attenuation)

# Check if audio is audible at current distance
func is_audible() -> bool:
    return get_distance_volume() > 0.001  # Threshold for audibility

# Internal methods (called by engine)
func _play_spatial_audio_stream():
    # This would interface with the engine's spatial audio system
    _update_spatial_audio()

func _stop_audio_stream():
    # This would interface with the engine's audio system
    pass

func _pause_audio_stream():
    # This would interface with the engine's audio system
    pass

func _resume_audio_stream():
    # This would interface with the engine's audio system
    pass

func _update_spatial_audio():
    # This would update the spatial audio properties in the engine
    # Including position, volume, pitch, attenuation, etc.
    pass

func _update_doppler_effect(delta: float):
    # Calculate velocity for Doppler effect
    var velocity = (global_position - _last_position) / delta
    _last_position = global_position
    
    # Apply Doppler effect to pitch
    # This would be implemented by the audio system
    pass

# Convenience methods
func play_at_position(pos: Vector2, from_time: float = 0.0):
    """Play audio at specific position"""
    global_position = pos
    play(from_time)

func fade_in(duration: float):
    """Fade in the audio over time"""
    # This would be implemented by the engine's tween system
    pass

func fade_out(duration: float):
    """Fade out the audio over time"""
    # This would be implemented by the engine's tween system
    pass

# Signals (inherited from AudioStreamPlayer)
signal playback_started
signal playback_stopped
signal playback_paused
signal playback_resumed
signal playback_finished
signal stream_changed(new_stream: AudioStream)
signal volume_changed(new_volume_db: float)
signal pitch_changed(new_pitch: float)

# Additional 2D-specific signals
signal attenuation_changed(new_attenuation: float)
signal max_distance_changed(new_distance: float)
signal area_mask_changed(new_mask: int)
signal doppler_tracking_changed(new_mode: String)
