# Area2D - 2D area for collision detection and physics space override
# Detects when bodies enter/exit and can override physics properties
extends Node2D

# Detection Properties
export_group("Detection")
export var monitoring: bool = true  # Whether this area detects other bodies
export var monitorable: bool = true  # Whether this area can be detected by others

# Collision Properties
export_group("Collision")
export var collision_layer: int = 1  # Collision layer (bitmask)
export var collision_mask: int = 1  # Collision mask (what layers to detect)

# Physics Override - Gravity
export_group("Gravity")
export var gravity_space_override: String = "disabled"  # "disabled", "combine", "replace"
export var gravity: Vector2 = Vector2(0, 98)  # Gravity vector
export var gravity_point: Vector2 = Vector2(0, 0)  # Point gravity center
export var gravity_distance_scale: float = 0.0  # Distance scale for point gravity
export var gravity_vector: Vector2 = Vector2(0, 1)  # Gravity direction (normalized)

# Physics Override - Linear Damping
export_group("Linear Damping")
export var linear_damp_space_override: String = "disabled"  # "disabled", "combine", "replace"
export var linear_damp: float = 0.1  # Linear damping value

# Physics Override - Angular Damping
export_group("Angular Damping")
export var angular_damp_space_override: String = "disabled"  # "disabled", "combine", "replace"
export var angular_damp: float = 1.0  # Angular damping value

# Audio Properties
export_group("Audio")
export var audio_bus_override: bool = false  # Override audio bus
export var audio_bus_name: String = "Master"  # Audio bus name

# Internal properties
var _overlapping_bodies: Array = []  # Bodies currently overlapping
var _overlapping_areas: Array = []  # Areas currently overlapping

# Called when the node enters the scene tree
func _ready():
    # Initialize area detection
    _setup_area_detection()

# Called every frame
func _process(delta: float):
    # Update area detection if monitoring is enabled
    if monitoring:
        _update_area_detection()

# Setup area detection system
func _setup_area_detection():
    # Implementation will be handled by physics system
    pass

# Update area detection
func _update_area_detection():
    # Implementation will be handled by physics system
    pass

# Check if a body is overlapping this area
func overlaps_body(body: Node2D) -> bool:
    return body in _overlapping_bodies

# Check if an area is overlapping this area
func overlaps_area(area: Node2D) -> bool:
    return area in _overlapping_areas

# Get all overlapping bodies
func get_overlapping_bodies() -> Array:
    return _overlapping_bodies.duplicate()

# Get all overlapping areas
func get_overlapping_areas() -> Array:
    return _overlapping_areas.duplicate()

# Set collision layer bit
func set_collision_layer_bit(bit: int, value: bool):
    if bit >= 0 and bit < 32:
        if value:
            collision_layer |= (1 << bit)
        else:
            collision_layer &= ~(1 << bit)

# Get collision layer bit
func get_collision_layer_bit(bit: int) -> bool:
    if bit >= 0 and bit < 32:
        return (collision_layer & (1 << bit)) != 0
    return false

# Set collision mask bit
func set_collision_mask_bit(bit: int, value: bool):
    if bit >= 0 and bit < 32:
        if value:
            collision_mask |= (1 << bit)
        else:
            collision_mask &= ~(1 << bit)

# Get collision mask bit
func get_collision_mask_bit(bit: int) -> bool:
    if bit >= 0 and bit < 32:
        return (collision_mask & (1 << bit)) != 0
    return false

# Set gravity override
func set_gravity_space_override(mode: String):
    if mode in ["disabled", "combine", "replace"]:
        gravity_space_override = mode

# Set gravity vector
func set_gravity(new_gravity: Vector2):
    gravity = new_gravity

# Set point gravity
func set_gravity_point(point: Vector2, distance_scale: float = 0.0):
    gravity_point = point
    gravity_distance_scale = distance_scale

# Set linear damping override
func set_linear_damp_space_override(mode: String):
    if mode in ["disabled", "combine", "replace"]:
        linear_damp_space_override = mode

# Set linear damping value
func set_linear_damp(value: float):
    linear_damp = value

# Set angular damping override
func set_angular_damp_space_override(mode: String):
    if mode in ["disabled", "combine", "replace"]:
        angular_damp_space_override = mode

# Set angular damping value
func set_angular_damp(value: float):
    angular_damp = value

# Enable/disable monitoring
func set_monitoring(enabled: bool):
    monitoring = enabled
    if not monitoring:
        # Clear overlapping bodies when monitoring is disabled
        _clear_overlapping_bodies()

# Enable/disable monitorable
func set_monitorable(enabled: bool):
    monitorable = enabled

# Clear all overlapping bodies (internal)
func _clear_overlapping_bodies():
    for body in _overlapping_bodies:
        emit_signal("body_exited", body)
    
    for area in _overlapping_areas:
        emit_signal("area_exited", area)
    
    _overlapping_bodies.clear()
    _overlapping_areas.clear()

# Handle body entering area (called by physics system)
func _on_body_entered(body: Node2D):
    if body not in _overlapping_bodies:
        _overlapping_bodies.append(body)
        emit_signal("body_entered", body)

# Handle body exiting area (called by physics system)
func _on_body_exited(body: Node2D):
    if body in _overlapping_bodies:
        _overlapping_bodies.erase(body)
        emit_signal("body_exited", body)

# Handle area entering area (called by physics system)
func _on_area_entered(area: Node2D):
    if area not in _overlapping_areas:
        _overlapping_areas.append(area)
        emit_signal("area_entered", area)

# Handle area exiting area (called by physics system)
func _on_area_exited(area: Node2D):
    if area in _overlapping_areas:
        _overlapping_areas.erase(area)
        emit_signal("area_exited", area)

# Get area data for physics system
func get_area_data() -> Dictionary:
    return {
        "monitoring": monitoring,
        "monitorable": monitorable,
        "collision_layer": collision_layer,
        "collision_mask": collision_mask,
        "gravity_space_override": gravity_space_override,
        "gravity": gravity,
        "gravity_point": gravity_point,
        "gravity_distance_scale": gravity_distance_scale,
        "gravity_vector": gravity_vector,
        "linear_damp_space_override": linear_damp_space_override,
        "linear_damp": linear_damp,
        "angular_damp_space_override": angular_damp_space_override,
        "angular_damp": angular_damp,
        "audio_bus_override": audio_bus_override,
        "audio_bus_name": audio_bus_name
    }

# Check if area should affect a body based on collision layers
func should_affect_body(body: Node2D) -> bool:
    if not body or not monitoring:
        return false
    
    # Check if body's collision layer matches our collision mask
    var body_layer = body.get("collision_layer")
    if body_layer == null:
        return false
    
    return (collision_mask & body_layer) != 0

# Apply physics overrides to a body
func apply_physics_overrides(body: Node2D):
    if not should_affect_body(body):
        return
    
    # Apply gravity override
    if gravity_space_override != "disabled":
        _apply_gravity_override(body)
    
    # Apply linear damping override
    if linear_damp_space_override != "disabled":
        _apply_linear_damp_override(body)
    
    # Apply angular damping override
    if angular_damp_space_override != "disabled":
        _apply_angular_damp_override(body)

# Apply gravity override to body
func _apply_gravity_override(body: Node2D):
    # Implementation will be handled by physics system
    pass

# Apply linear damping override to body
func _apply_linear_damp_override(body: Node2D):
    # Implementation will be handled by physics system
    pass

# Apply angular damping override to body
func _apply_angular_damp_override(body: Node2D):
    # Implementation will be handled by physics system
    pass

# Signals
signal body_entered(body)  # Emitted when a body enters the area
signal body_exited(body)  # Emitted when a body exits the area
signal area_entered(area)  # Emitted when another area enters this area
signal area_exited(area)  # Emitted when another area exits this area
