# Camera2D Node - Enhanced 2D camera with following and limits
# Provides viewport control, camera following, limits, and effects
extends Node2D

# Camera State
export_group("Camera State")
export var current: bool = false  # Whether this camera is active
export var enabled: bool = true  # Whether camera is enabled

# Transform
export_group("Transform")
export var offset: Vector2 = Vector2(0, 0)  # Camera offset from position
export var zoom: Vector2 = Vector2(1.0, 1.0)  # Camera zoom (1.0 = normal, 2.0 = 2x zoom)

# Anchor & Drag
export_group("Anchor & Drag")
export var anchor_mode: String = "fixed_top_left"  # "fixed_top_left", "drag_center"
export var drag_margin_h_enabled: bool = false  # Enable horizontal drag margins
export var drag_margin_v_enabled: bool = false  # Enable vertical drag margins
export var drag_margin_left: float = 0.2  # Left drag margin (0.0-1.0)
export var drag_margin_top: float = 0.2  # Top drag margin (0.0-1.0)
export var drag_margin_right: float = 0.2  # Right drag margin (0.0-1.0)
export var drag_margin_bottom: float = 0.2  # Bottom drag margin (0.0-1.0)

# Limits
export_group("Limits")
export var limit_left: int = -10000000  # Left boundary limit
export var limit_top: int = -10000000  # Top boundary limit
export var limit_right: int = 10000000  # Right boundary limit
export var limit_bottom: int = 10000000  # Bottom boundary limit
export var limit_smoothed: bool = false  # Smooth limit transitions

# Smoothing
export_group("Smoothing")
export var smoothing_enabled: bool = false  # Enable camera smoothing
export var smoothing_speed: float = 5.0  # Smoothing speed (higher = faster)

# Following
export_group("Following")
export var follow_target: nodepath = ""  # Node to follow (uses node picker)
export var follow_smoothing: bool = true  # Use smoothing when following
export var auto_follow_player: bool = false  # Automatically find and follow PlayerController

# Camera Shake
export_group("Camera Shake")
export var shake_intensity: float = 0.0  # Current shake intensity
export var shake_duration: float = 0.0  # Shake duration
export var shake_timer: float = 0.0  # Internal shake timer

# Process
export_group("Process")
export var process_mode: String = "idle"  # "idle", "physics", "always"

# Internal variables
var _target_position: Vector2 = Vector2.ZERO
var _shake_offset: Vector2 = Vector2.ZERO

# Called when the node enters the scene tree for the first time
func _ready():
    # Make this camera current if no other camera is current
    if current:
        make_current()

    # Auto-follow PlayerController if enabled and no follow target is set
    if auto_follow_player and follow_target == "":
        _auto_setup_follow_target()

# Called every frame. 'delta' is the elapsed time since the previous frame
func _process(delta):
    if not enabled or not current:
        return
    
    # Update camera shake
    if shake_timer > 0:
        shake_timer -= delta
        if shake_timer <= 0:
            shake_intensity = 0.0
            _shake_offset = Vector2.ZERO
        else:
            # Generate random shake offset
            var shake_x = (randf() - 0.5) * 2.0 * shake_intensity
            var shake_y = (randf() - 0.5) * 2.0 * shake_intensity
            _shake_offset = Vector2(shake_x, shake_y)
    
    # Update following
    if follow_target != "":
        var target_node = get_node(follow_target)
        if target_node:
            update_follow_target(target_node, delta)
    
    # Apply camera limits
    apply_limits()

# Make this camera the current active camera
func make_current():
    current = true
    # Disable other cameras (simplified - in full implementation would search scene)
    # emit_signal("camera_changed", self)

# Set the camera as not current
func clear_current():
    current = false

# Start camera shake effect
func shake(intensity: float, duration: float):
    shake_intensity = intensity
    shake_duration = duration
    shake_timer = duration

# Stop camera shake
func stop_shake():
    shake_intensity = 0.0
    shake_duration = 0.0
    shake_timer = 0.0
    _shake_offset = Vector2.ZERO

# Set follow target by node
func set_follow_target_node(target: Node):
    if target:
        follow_target = get_path_to(target)
    else:
        follow_target = ""

# Get follow target node
func get_follow_target_node() -> Node:
    if follow_target != "":
        return get_node(follow_target)
    return null

# Update camera position to follow target
func update_follow_target(target: Node, delta: float):
    if not target:
        return
    
    var target_pos = Vector2.ZERO
    
    # Get target position (handle different node types)
    if target.has_method("get_global_position"):
        target_pos = target.get_global_position()
    elif target.has_property("position"):
        target_pos = target.position
    elif target.has_property("global_position"):
        target_pos = target.global_position
    
    # Apply drag margins if enabled
    if drag_margin_h_enabled or drag_margin_v_enabled:
        apply_drag_margins(target_pos)
    else:
        _target_position = target_pos
    
    # Apply smoothing
    if follow_smoothing and smoothing_enabled:
        var smooth_factor = smoothing_speed * delta
        position = position.lerp(_target_position, smooth_factor)
    else:
        position = _target_position

# Apply drag margins for camera following
func apply_drag_margins(target_pos: Vector2):
    var screen_size = get_viewport_rect().size
    var camera_pos = position
    
    # Calculate drag boundaries
    var left_boundary = camera_pos.x - screen_size.x * drag_margin_left / zoom.x
    var right_boundary = camera_pos.x + screen_size.x * drag_margin_right / zoom.x
    var top_boundary = camera_pos.y - screen_size.y * drag_margin_top / zoom.y
    var bottom_boundary = camera_pos.y + screen_size.y * drag_margin_bottom / zoom.y
    
    # Update target position based on drag margins
    _target_position = camera_pos
    
    if drag_margin_h_enabled:
        if target_pos.x < left_boundary:
            _target_position.x = target_pos.x + screen_size.x * drag_margin_left / zoom.x
        elif target_pos.x > right_boundary:
            _target_position.x = target_pos.x - screen_size.x * drag_margin_right / zoom.x
    
    if drag_margin_v_enabled:
        if target_pos.y < top_boundary:
            _target_position.y = target_pos.y + screen_size.y * drag_margin_top / zoom.y
        elif target_pos.y > bottom_boundary:
            _target_position.y = target_pos.y - screen_size.y * drag_margin_bottom / zoom.y

# Apply camera limits
func apply_limits():
    var limited_pos = position
    
    # Apply position limits
    limited_pos.x = clamp(limited_pos.x, limit_left, limit_right)
    limited_pos.y = clamp(limited_pos.y, limit_top, limit_bottom)
    
    # Apply smoothing to limits if enabled
    if limit_smoothed and smoothing_enabled:
        position = position.lerp(limited_pos, smoothing_speed * get_process_delta_time())
    else:
        position = limited_pos

# Get effective camera position (including shake)
func get_camera_position() -> Vector2:
    return position + offset + _shake_offset

# Auto-setup follow target to PlayerController
func _auto_setup_follow_target():
    # Find PlayerController in the scene
    var scene_root = get_tree().current_scene
    if scene_root:
        var player_controller = _find_player_controller(scene_root)
        if player_controller:
            follow_target = get_path_to(player_controller)
            print("Camera auto-following PlayerController: " + player_controller.name)

# Recursively find PlayerController node
func _find_player_controller(node):
    # Check if this node is a PlayerController (KinematicBody2D with PlayerController script)
    if node.get_script() and node.get_script().get_path().ends_with("PlayerController.lsc"):
        return node

    # Check children
    for child in node.get_children():
        var result = _find_player_controller(child)
        if result:
            return result

    return null

# Get camera screen center in world coordinates
func get_camera_screen_center() -> Vector2:
    return get_camera_position()

# Convert screen position to world position
func screen_to_world(screen_pos: Vector2) -> Vector2:
    var camera_pos = get_camera_position()
    var screen_size = get_viewport_rect().size
    var world_pos = camera_pos + (screen_pos - screen_size / 2) / zoom
    return world_pos

# Convert world position to screen position
func world_to_screen(world_pos: Vector2) -> Vector2:
    var camera_pos = get_camera_position()
    var screen_size = get_viewport_rect().size
    var screen_pos = (world_pos - camera_pos) * zoom + screen_size / 2
    return screen_pos

# Check if a point is visible in camera view
func is_position_visible(world_pos: Vector2) -> bool:
    var screen_pos = world_to_screen(world_pos)
    var screen_size = get_viewport_rect().size
    return screen_pos.x >= 0 and screen_pos.x <= screen_size.x and screen_pos.y >= 0 and screen_pos.y <= screen_size.y

# Get camera bounds in world coordinates
func get_camera_bounds() -> Rect2:
    var camera_pos = get_camera_position()
    var screen_size = get_viewport_rect().size
    var world_size = screen_size / zoom
    return Rect2(camera_pos - world_size / 2, world_size)

# Signals
signal camera_changed(camera)  # Emitted when camera becomes current
signal shake_finished  # Emitted when camera shake ends
