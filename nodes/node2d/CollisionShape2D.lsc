# CollisionShape2D - 2D collision shape for physics bodies
# Provides collision detection for RigidBody2D, StaticBody2D, KinematicBody2D, and Area2D
extends Node2D

# Shape Properties
export_group("Shape")
export var shape: String = "rectangle"  # "rectangle", "circle", "capsule", "segment"
export var disabled: bool = false  # Whether collision is disabled

# One-way Collision
export_group("One-way Collision")
export var one_way_collision: bool = false  # Enable one-way collision
export var one_way_collision_margin: float = 1.0  # Margin for one-way collision

# Rectangle Shape Properties
export_group("Rectangle")
export var size: Vector2 = Vector2(32, 32)  # Size of rectangle shape

# Circle Shape Properties
export_group("Circle")
export var radius: float = 16.0  # Radius of circle shape

# Capsule Shape Properties
export_group("Capsule")
export var capsule_radius: float = 16.0  # Radius of capsule
export var height: float = 32.0  # Height of capsule

# Segment Shape Properties
export_group("Segment")
export var point_a: Vector2 = Vector2(0, 0)  # First point of segment
export var point_b: Vector2 = Vector2(32, 0)  # Second point of segment

# Debug Properties
export_group("Debug")
export var debug_color: Color = Color(0.0, 0.6, 0.7, 0.5)  # Debug visualization color

# Internal properties
var _physics_body: Node2D = null  # Reference to parent physics body

# Called when the node enters the scene tree
func _ready():
    # Find parent physics body
    _physics_body = get_parent()
    
    # Validate parent is a physics body
    if not _is_physics_body(_physics_body):
        print("Warning: CollisionShape2D should be child of physics body (RigidBody2D, StaticBody2D, KinematicBody2D, or Area2D)")

# Called every frame
func _process(delta: float):
    # Update collision shape if properties changed
    _update_collision_shape()

# Check if node is a physics body
func _is_physics_body(node: Node) -> bool:
    if not node:
        return false
    
    var node_type = node.get("type")
    return node_type in ["RigidBody2D", "StaticBody2D", "KinematicBody2D", "Area2D"]

# Update collision shape based on current properties
func _update_collision_shape():
    if not _physics_body:
        return
    
    # Update shape properties based on shape type
    match shape:
        "rectangle":
            _update_rectangle_shape()
        "circle":
            _update_circle_shape()
        "capsule":
            _update_capsule_shape()
        "segment":
            _update_segment_shape()

# Update rectangle collision shape
func _update_rectangle_shape():
    # Implementation will be handled by physics system
    pass

# Update circle collision shape
func _update_circle_shape():
    # Implementation will be handled by physics system
    pass

# Update capsule collision shape
func _update_capsule_shape():
    # Implementation will be handled by physics system
    pass

# Update segment collision shape
func _update_segment_shape():
    # Implementation will be handled by physics system
    pass

# Get shape bounds for debug rendering
func get_shape_bounds() -> Rect2:
    match shape:
        "rectangle":
            return Rect2(-size / 2, size)
        "circle":
            var diameter = radius * 2
            return Rect2(Vector2(-radius, -radius), Vector2(diameter, diameter))
        "capsule":
            var width = capsule_radius * 2
            return Rect2(Vector2(-capsule_radius, -height / 2), Vector2(width, height))
        "segment":
            var min_x = min(point_a.x, point_b.x)
            var max_x = max(point_a.x, point_b.x)
            var min_y = min(point_a.y, point_b.y)
            var max_y = max(point_a.y, point_b.y)
            return Rect2(Vector2(min_x, min_y), Vector2(max_x - min_x, max_y - min_y))
        _:
            return Rect2(Vector2.ZERO, Vector2(32, 32))

# Set shape type and update properties
func set_shape_type(new_shape: String):
    if new_shape in ["rectangle", "circle", "capsule", "segment"]:
        shape = new_shape
        _update_collision_shape()

# Enable/disable collision
func set_disabled(is_disabled: bool):
    disabled = is_disabled
    _update_collision_shape()

# Set one-way collision
func set_one_way_collision(enabled: bool, margin: float = 1.0):
    one_way_collision = enabled
    one_way_collision_margin = margin
    _update_collision_shape()

# Set rectangle size
func set_rectangle_size(new_size: Vector2):
    size = new_size
    if shape == "rectangle":
        _update_collision_shape()

# Set circle radius
func set_circle_radius(new_radius: float):
    radius = new_radius
    if shape == "circle":
        _update_collision_shape()

# Set capsule properties
func set_capsule_properties(new_radius: float, new_height: float):
    capsule_radius = new_radius
    height = new_height
    if shape == "capsule":
        _update_collision_shape()

# Set segment points
func set_segment_points(new_point_a: Vector2, new_point_b: Vector2):
    point_a = new_point_a
    point_b = new_point_b
    if shape == "segment":
        _update_collision_shape()

# Get collision shape data for physics system
func get_collision_data() -> Dictionary:
    var data = {
        "shape": shape,
        "disabled": disabled,
        "one_way_collision": one_way_collision,
        "one_way_collision_margin": one_way_collision_margin,
        "debug_color": debug_color
    }
    
    match shape:
        "rectangle":
            data["size"] = size
        "circle":
            data["radius"] = radius
        "capsule":
            data["radius"] = capsule_radius
            data["height"] = height
        "segment":
            data["point_a"] = point_a
            data["point_b"] = point_b
    
    return data

# Signals
signal shape_changed(shape_type)  # Emitted when shape type changes
signal properties_changed  # Emitted when shape properties change
