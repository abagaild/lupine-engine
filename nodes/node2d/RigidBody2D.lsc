# RigidBody2D - 2D rigid body with physics simulation
# Simulates realistic physics with gravity, forces, and collisions
extends Node2D

# Physics Mode
export_group("Physics")
export var mode: String = "rigid"  # "rigid", "static", "character", "kinematic"
export var mass: float = 1.0  # Body mass
export var weight: float = 9.8  # Body weight (mass * gravity)
export var physics_material_override: String = ""  # Physics material resource

# Damping
export_group("Damping")
export var linear_damp: float = -1.0  # Linear damping (-1 uses global default)
export var angular_damp: float = -1.0  # Angular damping (-1 uses global default)

# Collision
export_group("Collision")
export var collision_layer: int = 1  # Collision layer (bitmask)
export var collision_mask: int = 1  # Collision mask (what layers to collide with)

# Motion
export_group("Motion")
export var gravity_scale: float = 1.0  # Gravity scale multiplier
export var can_sleep: bool = true  # Whether body can sleep when at rest
export var sleeping: bool = false  # Whether body is currently sleeping
export var lock_rotation: bool = false  # Lock rotation axis

# Continuous Collision Detection
export_group("CCD")
export var continuous_cd: String = "disabled"  # "disabled", "cast_ray", "cast_shape"
export var contacts_reported: int = 0  # Maximum contacts to report (0 = unlimited)
export var contact_monitor: bool = false  # Enable contact monitoring

# Advanced
export_group("Advanced")
export var custom_integrator: bool = false  # Use custom integration

# Internal properties
var _linear_velocity: Vector2 = Vector2.ZERO  # Current linear velocity
var _angular_velocity: float = 0.0  # Current angular velocity
var _applied_forces: Array = []  # Forces applied this frame
var _applied_impulses: Array = []  # Impulses applied this frame
var _contacts: Array = []  # Current collision contacts

# Called when the node enters the scene tree
func _ready():
    # Initialize physics body
    _setup_physics_body()

# Called every physics frame
func _physics_process(delta: float):
    # Handle custom integration if enabled
    if custom_integrator:
        _integrate_forces(delta)

# Setup physics body
func _setup_physics_body():
    # Implementation will be handled by physics system
    pass

# Custom force integration
func _integrate_forces(delta: float):
    # Override this method for custom physics behavior
    pass

# Apply force at center of mass
func apply_central_force(force: Vector2):
    _applied_forces.append({
        "type": "central",
        "force": force
    })

# Apply force at specific position
func apply_force(force: Vector2, position: Vector2):
    _applied_forces.append({
        "type": "positional",
        "force": force,
        "position": position
    })

# Apply torque (rotational force)
func apply_torque(torque: float):
    _applied_forces.append({
        "type": "torque",
        "torque": torque
    })

# Apply central impulse (instant velocity change)
func apply_central_impulse(impulse: Vector2):
    _applied_impulses.append({
        "type": "central",
        "impulse": impulse
    })

# Apply impulse at specific position
func apply_impulse(impulse: Vector2, position: Vector2):
    _applied_impulses.append({
        "type": "positional",
        "impulse": impulse,
        "position": position
    })

# Apply torque impulse (instant angular velocity change)
func apply_torque_impulse(impulse: float):
    _applied_impulses.append({
        "type": "torque",
        "impulse": impulse
    })

# Set linear velocity
func set_linear_velocity(velocity: Vector2):
    _linear_velocity = velocity

# Get linear velocity
func get_linear_velocity() -> Vector2:
    return _linear_velocity

# Set angular velocity
func set_angular_velocity(velocity: float):
    _angular_velocity = velocity

# Get angular velocity
func get_angular_velocity() -> float:
    return _angular_velocity

# Set physics mode
func set_mode(new_mode: String):
    if new_mode in ["rigid", "static", "character", "kinematic"]:
        mode = new_mode
        _setup_physics_body()

# Set mass and update weight
func set_mass(new_mass: float):
    mass = max(0.01, new_mass)  # Minimum mass to avoid division by zero
    weight = mass * 9.8  # Update weight

# Set weight and update mass
func set_weight(new_weight: float):
    weight = max(0.01, new_weight)
    mass = weight / 9.8  # Update mass

# Set gravity scale
func set_gravity_scale(scale: float):
    gravity_scale = scale

# Enable/disable sleeping
func set_can_sleep(can_sleep_enabled: bool):
    can_sleep = can_sleep_enabled

# Set sleeping state
func set_sleeping(is_sleeping: bool):
    sleeping = is_sleeping

# Wake up the body
func wake_up():
    sleeping = false

# Put body to sleep
func sleep():
    if can_sleep:
        sleeping = true
        _linear_velocity = Vector2.ZERO
        _angular_velocity = 0.0

# Lock/unlock rotation
func set_lock_rotation(locked: bool):
    lock_rotation = locked

# Set collision layer bit
func set_collision_layer_bit(bit: int, value: bool):
    if bit >= 0 and bit < 32:
        if value:
            collision_layer |= (1 << bit)
        else:
            collision_layer &= ~(1 << bit)

# Get collision layer bit
func get_collision_layer_bit(bit: int) -> bool:
    if bit >= 0 and bit < 32:
        return (collision_layer & (1 << bit)) != 0
    return false

# Set collision mask bit
func set_collision_mask_bit(bit: int, value: bool):
    if bit >= 0 and bit < 32:
        if value:
            collision_mask |= (1 << bit)
        else:
            collision_mask &= ~(1 << bit)

# Get collision mask bit
func get_collision_mask_bit(bit: int) -> bool:
    if bit >= 0 and bit < 32:
        return (collision_mask & (1 << bit)) != 0
    return false

# Set continuous collision detection mode
func set_continuous_collision_detection_mode(ccd_mode: String):
    if ccd_mode in ["disabled", "cast_ray", "cast_shape"]:
        continuous_cd = ccd_mode

# Enable/disable contact monitoring
func set_contact_monitor(enabled: bool):
    contact_monitor = enabled
    if not enabled:
        _contacts.clear()

# Set maximum contacts reported
func set_max_contacts_reported(max_contacts: int):
    contacts_reported = max(0, max_contacts)

# Get colliding bodies
func get_colliding_bodies() -> Array:
    var bodies = []
    for contact in _contacts:
        if contact.has("body") and contact.body not in bodies:
            bodies.append(contact.body)
    return bodies

# Check if colliding with specific body
func is_colliding_with(body: Node2D) -> bool:
    for contact in _contacts:
        if contact.has("body") and contact.body == body:
            return true
    return false

# Get contact count
func get_contact_count() -> int:
    return _contacts.size()

# Get contact information
func get_contact_info(index: int) -> Dictionary:
    if index >= 0 and index < _contacts.size():
        return _contacts[index]
    return {}

# Handle collision contact (called by physics system)
func _on_body_contact(body: Node2D, contact_point: Vector2, contact_normal: Vector2, impulse: float):
    if contact_monitor:
        var contact_info = {
            "body": body,
            "point": contact_point,
            "normal": contact_normal,
            "impulse": impulse
        }
        
        _contacts.append(contact_info)
        
        # Limit contacts if specified
        if contacts_reported > 0 and _contacts.size() > contacts_reported:
            _contacts.pop_front()
        
        emit_signal("body_entered", body)

# Handle collision separation (called by physics system)
func _on_body_separation(body: Node2D):
    if contact_monitor:
        # Remove contacts with this body
        for i in range(_contacts.size() - 1, -1, -1):
            if _contacts[i].has("body") and _contacts[i].body == body:
                _contacts.remove(i)
        
        emit_signal("body_exited", body)

# Get physics data for physics system
func get_physics_data() -> Dictionary:
    return {
        "mode": mode,
        "mass": mass,
        "weight": weight,
        "physics_material_override": physics_material_override,
        "linear_damp": linear_damp,
        "angular_damp": angular_damp,
        "collision_layer": collision_layer,
        "collision_mask": collision_mask,
        "gravity_scale": gravity_scale,
        "can_sleep": can_sleep,
        "sleeping": sleeping,
        "lock_rotation": lock_rotation,
        "continuous_cd": continuous_cd,
        "contacts_reported": contacts_reported,
        "contact_monitor": contact_monitor,
        "custom_integrator": custom_integrator,
        "linear_velocity": _linear_velocity,
        "angular_velocity": _angular_velocity,
        "applied_forces": _applied_forces,
        "applied_impulses": _applied_impulses
    }

# Clear applied forces and impulses (called by physics system)
func _clear_forces():
    _applied_forces.clear()
    _applied_impulses.clear()

# Signals
signal body_entered(body)  # Emitted when body starts colliding
signal body_exited(body)  # Emitted when body stops colliding
signal sleeping_state_changed  # Emitted when sleeping state changes
