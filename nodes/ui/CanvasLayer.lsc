# CanvasLayer Node - Canvas layer for UI and effects with independent rendering
# Provides layer-based rendering system for UI elements and effects
extends Node

# Layer Properties
export_group("Layer Properties")
export var layer: int = 1  # Layer index for Z-ordering (higher = on top)

# Transform
export_group("Transform")
export var offset: Vector2 = Vector2(0, 0)  # Layer offset
export var rotation: float = 0.0  # Layer rotation in radians
export var scale: Vector2 = Vector2(1.0, 1.0)  # Layer scale

# Viewport
export_group("Viewport")
export var follow_viewport_enable: bool = false  # Follow viewport transformations
export var follow_viewport_scale: float = 1.0  # Scale factor for viewport following

# Custom Viewport
export_group("Custom Viewport")
export var custom_viewport: Viewport = null  # Custom viewport (if not following main viewport)

# Internal variables
var _transform_matrix: Transform2D = Transform2D()
var _viewport_size: Vector2 = Vector2.ZERO

# Called when the node enters the scene tree for the first time
func _ready():
    # Initialize transform matrix
    update_transform_matrix()
    
    # Connect to viewport size changes
    if get_viewport():
        _viewport_size = get_viewport().get_visible_rect().size
        get_viewport().connect("size_changed", self, "_on_viewport_size_changed")

# Called every frame. 'delta' is the elapsed time since the previous frame
func _process(delta):
    # Update transform matrix if properties changed
    update_transform_matrix()
    
    # Update viewport following if enabled
    if follow_viewport_enable:
        update_viewport_following()

# Update the transform matrix for this layer
func update_transform_matrix():
    _transform_matrix = Transform2D()
    
    # Apply scale
    _transform_matrix = _transform_matrix.scaled(scale)
    
    # Apply rotation
    _transform_matrix = _transform_matrix.rotated(rotation)
    
    # Apply offset
    _transform_matrix.origin = offset

# Update viewport following
func update_viewport_following():
    if not follow_viewport_enable:
        return
    
    var viewport = get_viewport()
    if not viewport:
        return
    
    # Get viewport camera if available
    var camera = viewport.get_camera()
    if camera and camera.has_method("get_camera_position"):
        var camera_pos = camera.get_camera_position()
        var camera_zoom = camera.zoom if camera.has_property("zoom") else Vector2(1, 1)
        
        # Apply viewport following with scale factor
        var follow_offset = camera_pos * follow_viewport_scale
        var follow_scale = camera_zoom * follow_viewport_scale
        
        # Update transform to follow viewport
        offset = follow_offset
        scale = follow_scale
        
        # Update transform matrix
        update_transform_matrix()

# Set the layer index
func set_layer(new_layer: int):
    if layer != new_layer:
        layer = new_layer
        # Emit signal for renderer to update layer ordering
        emit_signal("layer_changed", self, layer)

# Get the layer index
func get_layer() -> int:
    return layer

# Set layer offset
func set_offset(new_offset: Vector2):
    offset = new_offset
    update_transform_matrix()
    emit_signal("transform_changed", self)

# Get layer offset
func get_offset() -> Vector2:
    return offset

# Set layer rotation
func set_rotation(new_rotation: float):
    rotation = new_rotation
    update_transform_matrix()
    emit_signal("transform_changed", self)

# Get layer rotation
func get_rotation() -> float:
    return rotation

# Set layer scale
func set_scale(new_scale: Vector2):
    scale = new_scale
    update_transform_matrix()
    emit_signal("transform_changed", self)

# Get layer scale
func get_scale() -> Vector2:
    return scale

# Enable/disable viewport following
func set_follow_viewport_enable(enable: bool):
    follow_viewport_enable = enable
    if enable:
        update_viewport_following()
    else:
        # Reset to manual transform
        update_transform_matrix()
    emit_signal("viewport_following_changed", self, enable)

# Get viewport following state
func get_follow_viewport_enable() -> bool:
    return follow_viewport_enable

# Set viewport following scale
func set_follow_viewport_scale(scale_factor: float):
    follow_viewport_scale = scale_factor
    if follow_viewport_enable:
        update_viewport_following()

# Get viewport following scale
func get_follow_viewport_scale() -> float:
    return follow_viewport_scale

# Set custom viewport
func set_custom_viewport(viewport: Viewport):
    custom_viewport = viewport
    emit_signal("viewport_changed", self, viewport)

# Get custom viewport
func get_custom_viewport() -> Viewport:
    return custom_viewport

# Get effective viewport (custom or main)
func get_effective_viewport() -> Viewport:
    if custom_viewport:
        return custom_viewport
    return get_viewport()

# Get the transform matrix for this layer
func get_transform_matrix() -> Transform2D:
    return _transform_matrix

# Transform a point from layer space to screen space
func layer_to_screen(layer_point: Vector2) -> Vector2:
    return _transform_matrix * layer_point

# Transform a point from screen space to layer space
func screen_to_layer(screen_point: Vector2) -> Vector2:
    return _transform_matrix.affine_inverse() * screen_point

# Get layer bounds in screen coordinates
func get_layer_bounds() -> Rect2:
    var viewport = get_effective_viewport()
    if not viewport:
        return Rect2()
    
    var viewport_rect = viewport.get_visible_rect()
    var corners = [
        Vector2(0, 0),
        Vector2(viewport_rect.size.x, 0),
        Vector2(viewport_rect.size.x, viewport_rect.size.y),
        Vector2(0, viewport_rect.size.y)
    ]
    
    # Transform corners to layer space
    var min_pos = screen_to_layer(corners[0])
    var max_pos = min_pos
    
    for corner in corners:
        var layer_corner = screen_to_layer(corner)
        min_pos.x = min(min_pos.x, layer_corner.x)
        min_pos.y = min(min_pos.y, layer_corner.y)
        max_pos.x = max(max_pos.x, layer_corner.x)
        max_pos.y = max(max_pos.y, layer_corner.y)
    
    return Rect2(min_pos, max_pos - min_pos)

# Check if a point in layer space is visible
func is_layer_point_visible(layer_point: Vector2) -> bool:
    var screen_point = layer_to_screen(layer_point)
    var viewport = get_effective_viewport()
    if not viewport:
        return false
    
    var viewport_rect = viewport.get_visible_rect()
    return viewport_rect.has_point(screen_point)

# Get all child Control nodes in this layer
func get_layer_controls() -> Array:
    var controls = []
    
    func collect_controls(node: Node):
        if node.get_class() == "Control" or node.is_class("Control"):
            controls.append(node)
        for child in node.get_children():
            collect_controls(child)
    
    collect_controls(self)
    return controls

# Sort layer controls by z_layer
func sort_layer_controls() -> Array:
    var controls = get_layer_controls()
    
    # Sort by z_layer property
    controls.sort_custom(self, "_compare_z_layer")
    return controls

# Custom comparison function for z_layer sorting
func _compare_z_layer(a: Control, b: Control) -> bool:
    var a_z = a.z_layer if a.has_property("z_layer") else 0
    var b_z = b.z_layer if b.has_property("z_layer") else 0
    return a_z < b_z

# Called when viewport size changes
func _on_viewport_size_changed():
    var viewport = get_viewport()
    if viewport:
        _viewport_size = viewport.get_visible_rect().size
        emit_signal("viewport_size_changed", self, _viewport_size)

# Move layer up in Z-order
func move_layer_up():
    set_layer(layer + 1)

# Move layer down in Z-order
func move_layer_down():
    set_layer(max(0, layer - 1))

# Reset layer transform to defaults
func reset_transform():
    offset = Vector2.ZERO
    rotation = 0.0
    scale = Vector2.ONE
    update_transform_matrix()
    emit_signal("transform_changed", self)

# Signals
signal layer_changed(canvas_layer, new_layer)  # Emitted when layer index changes
signal transform_changed(canvas_layer)  # Emitted when transform properties change
signal viewport_following_changed(canvas_layer, enabled)  # Emitted when viewport following changes
signal viewport_changed(canvas_layer, viewport)  # Emitted when custom viewport changes
signal viewport_size_changed(canvas_layer, size)  # Emitted when viewport size changes
