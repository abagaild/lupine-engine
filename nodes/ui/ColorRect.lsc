# ColorRect Node - UI node that displays a solid color rectangle
# Simple and efficient way to display colored backgrounds, dividers, or UI elements
extends Control

# Color Properties
export_group("Color")
export var color: Color = Color(1.0, 1.0, 1.0, 1.0)  # RGBA color to display

# Called when the node enters the scene tree for the first time
func _ready():
    super._ready()
    
    # Set default size if not specified
    if rect_size == Vector2.ZERO:
        rect_size = Vector2(100, 100)

# Called every frame. 'delta' is the elapsed time since the previous frame
func _process(delta: float):
    pass

# Set the color
func set_color(new_color: Color):
    color = new_color
    # Emit signal for renderer update
    emit_signal("appearance_changed")

# Get the color
func get_color() -> Color:
    return color

# Set color from RGB values (0-255)
func set_color_rgb(r: int, g: int, b: int, a: int = 255):
    color = Color(r / 255.0, g / 255.0, b / 255.0, a / 255.0)
    emit_signal("appearance_changed")

# Set color from HSV values
func set_color_hsv(h: float, s: float, v: float, a: float = 1.0):
    color = Color.from_hsv(h, s, v, a)
    emit_signal("appearance_changed")

# Get the effective rect for drawing
func get_draw_rect() -> Rect2:
    return Rect2(position, rect_size)

# Check if a point is inside the color rect
func has_point(point: Vector2) -> bool:
    var rect = get_draw_rect()
    return rect.has_point(point)

# Fade the color to a target color over time
func fade_to_color(target_color: Color, duration: float):
    # This would be implemented by the engine's tween system
    # For now, just set the color directly
    set_color(target_color)

# Animate color alpha (fade in/out)
func fade_alpha(target_alpha: float, duration: float):
    var target_color = Color(color.r, color.g, color.b, target_alpha)
    fade_to_color(target_color, duration)

# Make the color rect fully opaque
func make_opaque():
    set_color(Color(color.r, color.g, color.b, 1.0))

# Make the color rect fully transparent
func make_transparent():
    set_color(Color(color.r, color.g, color.b, 0.0))

# Set alpha value only
func set_alpha(alpha: float):
    set_color(Color(color.r, color.g, color.b, clamp(alpha, 0.0, 1.0)))

# Get alpha value
func get_alpha() -> float:
    return color.a

# Brighten the color
func brighten(amount: float):
    var hsv = color.to_hsv()
    hsv.z = clamp(hsv.z + amount, 0.0, 1.0)
    set_color(Color.from_hsv(hsv.x, hsv.y, hsv.z, color.a))

# Darken the color
func darken(amount: float):
    brighten(-amount)

# Saturate the color
func saturate(amount: float):
    var hsv = color.to_hsv()
    hsv.y = clamp(hsv.y + amount, 0.0, 1.0)
    set_color(Color.from_hsv(hsv.x, hsv.y, hsv.z, color.a))

# Desaturate the color
func desaturate(amount: float):
    saturate(-amount)

# Shift hue
func shift_hue(amount: float):
    var hsv = color.to_hsv()
    hsv.x = fmod(hsv.x + amount, 1.0)
    if hsv.x < 0.0:
        hsv.x += 1.0
    set_color(Color.from_hsv(hsv.x, hsv.y, hsv.z, color.a))

# Get complementary color
func get_complementary_color() -> Color:
    var hsv = color.to_hsv()
    var comp_hue = fmod(hsv.x + 0.5, 1.0)
    return Color.from_hsv(comp_hue, hsv.y, hsv.z, color.a)

# Set to complementary color
func set_complementary_color():
    set_color(get_complementary_color())

# Blend with another color
func blend_with_color(other_color: Color, blend_factor: float):
    var blended = color.lerp(other_color, clamp(blend_factor, 0.0, 1.0))
    set_color(blended)

# Common color presets
func set_red():
    set_color(Color(1.0, 0.0, 0.0, color.a))

func set_green():
    set_color(Color(0.0, 1.0, 0.0, color.a))

func set_blue():
    set_color(Color(0.0, 0.0, 1.0, color.a))

func set_white():
    set_color(Color(1.0, 1.0, 1.0, color.a))

func set_black():
    set_color(Color(0.0, 0.0, 0.0, color.a))

func set_transparent():
    set_color(Color(color.r, color.g, color.b, 0.0))

# Signals
signal appearance_changed  # Emitted when visual properties change
signal color_changed(new_color: Color)  # Emitted when color changes
