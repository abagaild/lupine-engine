# Control - Base UI node with rect, layout, anchors, and margins
# Base class for all UI elements with positioning and layout capabilities
extends Node

# Layout properties - using 'position' instead of 'rect_position' per user preference
export_group("Layout")
export var position: Vector2 = Vector2(0, 0)  # Position of the control
export var rect_size: Vector2 = Vector2(100, 100)  # Size of the control
export var rect_min_size: Vector2 = Vector2(0, 0)  # Minimum size

# Anchor properties
export_group("Anchors")
export var anchor_left: float = 0.0  # Left anchor (0.0 to 1.0)
export var anchor_top: float = 0.0  # Top anchor (0.0 to 1.0)
export var anchor_right: float = 0.0  # Right anchor (0.0 to 1.0)
export var anchor_bottom: float = 0.0  # Bottom anchor (0.0 to 1.0)

# Margin properties
export_group("Margins")
export var margin_left: float = 0.0  # Left margin
export var margin_top: float = 0.0  # Top margin
export var margin_right: float = 0.0  # Right margin
export var margin_bottom: float = 0.0  # Bottom margin

# Size and behavior
export_group("Size Flags")
export var size_flags: Dictionary = {"expand_h": false, "expand_v": false}  # Size expansion flags

# Clipping and interaction
export_group("Behavior")
export var clip_contents: bool = false  # Whether to clip child contents
export var mouse_filter: String = "pass"  # Mouse filter: "stop", "pass", "ignore"
export var focus_mode: String = "none"  # Focus mode: "none", "click", "all"

# Theming and appearance
export_group("Theme")
export var theme: Resource = null  # Theme resource
export var modulate: Color = Color(1, 1, 1, 1)  # Color modulation
export var z_layer: int = 0  # Z-layer for UI rendering

# Internal state
var _has_focus: bool = false
var _mouse_inside: bool = false

# Called when the node enters the scene tree
func _ready():
    super._ready()

# Set position (using position instead of rect_position per user preference)
func set_position(new_position: Vector2):
    position = new_position

# Get position
func get_position() -> Vector2:
    return position

# Set size
func set_size(new_size: Vector2):
    rect_size = new_size

# Get size
func get_size() -> Vector2:
    return rect_size

# Set minimum size
func set_min_size(min_size: Vector2):
    rect_min_size = min_size

# Get minimum size
func get_min_size() -> Vector2:
    return rect_min_size

# Get the control's rectangle
func get_rect() -> Rect2:
    return Rect2(position, rect_size)

# Set the control's rectangle
func set_rect(rect: Rect2):
    position = rect.position
    rect_size = rect.size

# Get global rectangle (relative to viewport)
func get_global_rect() -> Rect2:
    var global_pos = get_global_position()
    return Rect2(global_pos, rect_size)

# Get global position (viewport-relative for UI)
func get_global_position() -> Vector2:
    if parent and parent is Control:
        return parent.get_global_position() + get_anchored_position()
    else:
        return get_anchored_position()

# Calculate position based on anchors and margins
func get_anchored_position() -> Vector2:
    if not parent or not parent is Control:
        return position

    var parent_size = parent.rect_size
    var anchor_pos = Vector2(
        anchor_left * parent_size.x,
        anchor_top * parent_size.y
    )

    return anchor_pos + Vector2(margin_left, margin_top)

# Calculate size based on anchors and margins
func get_anchored_size() -> Vector2:
    if not parent or not parent is Control:
        return rect_size

    var parent_size = parent.rect_size

    # If anchors define a range (right > left or bottom > top), calculate size from anchors
    if anchor_right > anchor_left or anchor_bottom > anchor_top:
        var anchor_width = (anchor_right - anchor_left) * parent_size.x
        var anchor_height = (anchor_bottom - anchor_top) * parent_size.y

        return Vector2(
            anchor_width - margin_left - margin_right,
            anchor_height - margin_top - margin_bottom
        )
    else:
        return rect_size

# Update position and size based on anchors (called when parent resizes)
func _update_anchored_layout():
    if parent and parent is Control:
        position = get_anchored_position()
        rect_size = get_anchored_size()
        emit_signal("resized")

# Anchor management
func set_anchor(side: String, anchor: float):
    match side:
        "left":
            anchor_left = anchor
        "top":
            anchor_top = anchor
        "right":
            anchor_right = anchor
        "bottom":
            anchor_bottom = anchor

func get_anchor(side: String) -> float:
    match side:
        "left":
            return anchor_left
        "top":
            return anchor_top
        "right":
            return anchor_right
        "bottom":
            return anchor_bottom
    return 0.0

func set_anchors_preset(preset: String, keep_margins: bool = false):
    var old_pos = position
    var old_size = rect_size

    match preset:
        "top_left":
            anchor_left = 0.0
            anchor_top = 0.0
            anchor_right = 0.0
            anchor_bottom = 0.0
        "top_right":
            anchor_left = 1.0
            anchor_top = 0.0
            anchor_right = 1.0
            anchor_bottom = 0.0
        "bottom_left":
            anchor_left = 0.0
            anchor_top = 1.0
            anchor_right = 0.0
            anchor_bottom = 1.0
        "bottom_right":
            anchor_left = 1.0
            anchor_top = 1.0
            anchor_right = 1.0
            anchor_bottom = 1.0
        "center":
            anchor_left = 0.5
            anchor_top = 0.5
            anchor_right = 0.5
            anchor_bottom = 0.5
        "center_left":
            anchor_left = 0.0
            anchor_top = 0.5
            anchor_right = 0.0
            anchor_bottom = 0.5
        "center_right":
            anchor_left = 1.0
            anchor_top = 0.5
            anchor_right = 1.0
            anchor_bottom = 0.5
        "center_top":
            anchor_left = 0.5
            anchor_top = 0.0
            anchor_right = 0.5
            anchor_bottom = 0.0
        "center_bottom":
            anchor_left = 0.5
            anchor_top = 1.0
            anchor_right = 0.5
            anchor_bottom = 1.0
        "left_wide":
            anchor_left = 0.0
            anchor_top = 0.0
            anchor_right = 0.0
            anchor_bottom = 1.0
        "top_wide":
            anchor_left = 0.0
            anchor_top = 0.0
            anchor_right = 1.0
            anchor_bottom = 0.0
        "right_wide":
            anchor_left = 1.0
            anchor_top = 0.0
            anchor_right = 1.0
            anchor_bottom = 1.0
        "bottom_wide":
            anchor_left = 0.0
            anchor_top = 1.0
            anchor_right = 1.0
            anchor_bottom = 1.0
        "vcenter_wide":
            anchor_left = 0.0
            anchor_top = 0.5
            anchor_right = 1.0
            anchor_bottom = 0.5
        "hcenter_wide":
            anchor_left = 0.5
            anchor_top = 0.0
            anchor_right = 0.5
            anchor_bottom = 1.0
        "full_rect":
            anchor_left = 0.0
            anchor_top = 0.0
            anchor_right = 1.0
            anchor_bottom = 1.0

    # Update margins to maintain position/size if requested
    if keep_margins and parent and parent is Control:
        _set_margins_from_position_size(old_pos, old_size)

    _update_anchored_layout()

# Helper function to set margins based on desired position and size
func _set_margins_from_position_size(desired_pos: Vector2, desired_size: Vector2):
    if not parent or not parent is Control:
        return

    var parent_size = parent.rect_size
    var anchor_pos = Vector2(
        anchor_left * parent_size.x,
        anchor_top * parent_size.y
    )

    margin_left = desired_pos.x - anchor_pos.x
    margin_top = desired_pos.y - anchor_pos.y

    if anchor_right > anchor_left:
        margin_right = anchor_pos.x + desired_size.x - (anchor_right * parent_size.x)
    if anchor_bottom > anchor_top:
        margin_bottom = anchor_pos.y + desired_size.y - (anchor_bottom * parent_size.y)

# Margin management
func set_margin(side: String, margin: float):
    match side:
        "left":
            margin_left = margin
        "top":
            margin_top = margin
        "right":
            margin_right = margin
        "bottom":
            margin_bottom = margin

func get_margin(side: String) -> float:
    match side:
        "left":
            return margin_left
        "top":
            return margin_top
        "right":
            return margin_right
        "bottom":
            return margin_bottom
    return 0.0

# Focus management
func grab_focus():
    _has_focus = true
    emit_signal("focus_entered")

func release_focus():
    _has_focus = false
    emit_signal("focus_exited")

func has_focus() -> bool:
    return _has_focus

# Mouse interaction
func set_mouse_filter(filter: String):
    mouse_filter = filter

func get_mouse_filter() -> String:
    return mouse_filter

# Check if point is inside control
func has_point(point: Vector2) -> bool:
    var rect = get_rect()
    return rect.has_point(point)

# Size flags
func set_h_size_flags(flags: int):
    size_flags["expand_h"] = (flags & 1) != 0

func set_v_size_flags(flags: int):
    size_flags["expand_v"] = (flags & 1) != 0

func get_h_size_flags() -> int:
    return 1 if size_flags.get("expand_h", false) else 0

func get_v_size_flags() -> int:
    return 1 if size_flags.get("expand_v", false) else 0

# Clipping
func set_clip_contents(clip: bool):
    clip_contents = clip

func is_clipping_contents() -> bool:
    return clip_contents

# Theme
func set_theme(new_theme: Resource):
    theme = new_theme

func get_theme() -> Resource:
    return theme

# Modulation
func set_modulate(color: Color):
    modulate = color

func get_modulate() -> Color:
    return modulate

# Signals
signal focus_entered  # Emitted when control gains focus
signal focus_exited   # Emitted when control loses focus
signal mouse_entered  # Emitted when mouse enters control
signal mouse_exited   # Emitted when mouse exits control
signal gui_input      # Emitted on input events
signal resized        # Emitted when control is resized
