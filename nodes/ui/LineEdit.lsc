# LineEdit Node - Single-line text input field with cursor, selection, and editing capabilities
# Equivalent to Godot's LineEdit with full text editing functionality
extends Control

# Text Properties
export_group("Text")
export var text: String = ""  # Current text content
export var placeholder_text: String = ""  # Placeholder text when empty
export var max_length: int = 0  # Maximum text length (0 = unlimited)
export var editable: bool = true  # Whether text can be edited

# Input Properties
export_group("Input")
export var secret: bool = false  # Hide text (password field)
export var secret_character: String = "*"  # Character to show for secret text
export var expand_to_text_length: bool = false  # Expand width to fit text
export var clear_button_enabled: bool = false  # Show clear button

# Selection Properties
export_group("Selection")
export var selecting_enabled: bool = true  # Allow text selection
export var context_menu_enabled: bool = true  # Show right-click context menu
export var virtual_keyboard_enabled: bool = true  # Show virtual keyboard on mobile

# Appearance Properties
export_group("Appearance")
export var align: String = "left"  # Text alignment: "left", "center", "right"

# Style Properties
export_group("Style")
export var background_color: Color = Color(0.1, 0.1, 0.1, 1.0)  # Background color
export var font_color: Color = Color(1.0, 1.0, 1.0, 1.0)  # Text color
export var font_color_selected: Color = Color(0.0, 0.0, 0.0, 1.0)  # Selected text color
export var selection_color: Color = Color(0.4, 0.4, 1.0, 0.5)  # Selection highlight color
export var cursor_color: Color = Color(1.0, 1.0, 1.0, 1.0)  # Cursor color
export var border_color: Color = Color(0.5, 0.5, 0.5, 1.0)  # Border color
export var border_width: float = 1.0  # Border thickness
export var corner_radius: float = 2.0  # Rounded corners

# Font Properties
export_group("Font")
export var font: Resource = null  # Font resource
export var font_size: int = 14  # Font size

# Internal state
var _cursor_position: int = 0  # Current cursor position
var _selection_start: int = -1  # Selection start position (-1 = no selection)
var _selection_end: int = -1  # Selection end position
var _scroll_offset: float = 0.0  # Horizontal scroll offset
var _has_focus: bool = false  # Whether the field has focus
var _cursor_blink_timer: float = 0.0  # Cursor blink timing
var _cursor_visible: bool = true  # Cursor visibility state
var _mouse_selecting: bool = false  # Whether mouse is selecting text

# Constants
const CURSOR_BLINK_SPEED = 1.0  # Cursor blinks per second
const SCROLL_MARGIN = 10.0  # Margin for auto-scrolling

# Alignment constants
const ALIGN_LEFT = "left"
const ALIGN_CENTER = "center"
const ALIGN_RIGHT = "right"

# Called when the node enters the scene tree
func _ready():
    super._ready()
    
    # Set default size if not specified
    if rect_size == Vector2.ZERO:
        rect_size = Vector2(200, 32)
    
    # Set focus mode to allow keyboard input
    focus_mode = "click"

# Called every frame
func _process(delta: float):
    # Update cursor blink
    if _has_focus and editable:
        _cursor_blink_timer += delta
        if _cursor_blink_timer >= (1.0 / CURSOR_BLINK_SPEED):
            _cursor_visible = !_cursor_visible
            _cursor_blink_timer = 0.0

# Set the text content
func set_text(new_text: String):
    var old_text = text
    
    # Apply max length limit
    if max_length > 0 and new_text.length() > max_length:
        new_text = new_text.substr(0, max_length)
    
    text = new_text
    
    # Clamp cursor position
    _cursor_position = min(_cursor_position, text.length())
    
    # Clear selection if text changed externally
    if old_text != text:
        _clear_selection()
    
    # Update scroll to keep cursor visible
    _update_scroll()
    
    # Emit signal
    if old_text != text:
        emit_signal("text_changed", text)

# Get the text content
func get_text() -> String:
    return text

# Set cursor position
func set_cursor_position(position: int):
    _cursor_position = clamp(position, 0, text.length())
    _clear_selection()
    _update_scroll()
    _reset_cursor_blink()

# Get cursor position
func get_cursor_position() -> int:
    return _cursor_position

# Select text range
func select(from: int = 0, to: int = -1):
    if not selecting_enabled:
        return
    
    if to == -1:
        to = text.length()
    
    _selection_start = clamp(from, 0, text.length())
    _selection_end = clamp(to, 0, text.length())
    
    # Ensure start <= end
    if _selection_start > _selection_end:
        var temp = _selection_start
        _selection_start = _selection_end
        _selection_end = temp
    
    _cursor_position = _selection_end

# Select all text
func select_all():
    select(0, text.length())

# Clear selection
func _clear_selection():
    _selection_start = -1
    _selection_end = -1

# Check if text is selected
func has_selection() -> bool:
    return _selection_start >= 0 and _selection_end >= 0 and _selection_start != _selection_end

# Get selected text
func get_selected_text() -> String:
    if not has_selection():
        return ""
    return text.substr(_selection_start, _selection_end - _selection_start)

# Delete selected text
func delete_selection():
    if not has_selection():
        return
    
    var new_text = text.substr(0, _selection_start) + text.substr(_selection_end)
    _cursor_position = _selection_start
    _clear_selection()
    set_text(new_text)

# Insert text at cursor position
func insert_text_at_cursor(insert_text: String):
    if not editable:
        return
    
    # Delete selection first if any
    if has_selection():
        delete_selection()
    
    # Insert new text
    var new_text = text.substr(0, _cursor_position) + insert_text + text.substr(_cursor_position)
    
    # Apply max length limit
    if max_length > 0 and new_text.length() > max_length:
        var available_length = max_length - text.length()
        if available_length > 0:
            insert_text = insert_text.substr(0, available_length)
            new_text = text.substr(0, _cursor_position) + insert_text + text.substr(_cursor_position)
        else:
            return
    
    _cursor_position += insert_text.length()
    set_text(new_text)

# Delete character at cursor (backspace)
func delete_char_at_cursor():
    if not editable or _cursor_position <= 0:
        return
    
    var new_text = text.substr(0, _cursor_position - 1) + text.substr(_cursor_position)
    _cursor_position -= 1
    set_text(new_text)

# Delete character after cursor (delete key)
func delete_char_after_cursor():
    if not editable or _cursor_position >= text.length():
        return
    
    var new_text = text.substr(0, _cursor_position) + text.substr(_cursor_position + 1)
    set_text(new_text)

# Clear all text
func clear():
    set_text("")
    _cursor_position = 0
    _clear_selection()

# Update horizontal scroll to keep cursor visible
func _update_scroll():
    # This would be implemented by the renderer
    pass

# Reset cursor blink timer
func _reset_cursor_blink():
    _cursor_blink_timer = 0.0
    _cursor_visible = true

# Focus management
func grab_focus():
    super.grab_focus()
    _has_focus = true
    _reset_cursor_blink()
    emit_signal("focus_entered")

func release_focus():
    super.release_focus()
    _has_focus = false
    _clear_selection()
    emit_signal("focus_exited")

# Input handling
func _input_event(event: InputEvent):
    if not _has_focus or not editable:
        return
    
    if event is InputEventKey and event.pressed:
        _handle_key_input(event)
    elif event is InputEventMouseButton:
        _handle_mouse_input(event)

# Handle keyboard input
func _handle_key_input(event: InputEventKey):
    match event.keycode:
        KEY_LEFT:
            if event.shift and selecting_enabled:
                _extend_selection_left()
            else:
                _move_cursor_left()
        KEY_RIGHT:
            if event.shift and selecting_enabled:
                _extend_selection_right()
            else:
                _move_cursor_right()
        KEY_HOME:
            if event.shift and selecting_enabled:
                _extend_selection_to_start()
            else:
                _move_cursor_to_start()
        KEY_END:
            if event.shift and selecting_enabled:
                _extend_selection_to_end()
            else:
                _move_cursor_to_end()
        KEY_BACKSPACE:
            if has_selection():
                delete_selection()
            else:
                delete_char_at_cursor()
        KEY_DELETE:
            if has_selection():
                delete_selection()
            else:
                delete_char_after_cursor()
        KEY_A:
            if event.ctrl:
                select_all()
        KEY_C:
            if event.ctrl and has_selection():
                # Copy to clipboard (would be implemented by engine)
                emit_signal("text_copied", get_selected_text())
        KEY_X:
            if event.ctrl and has_selection():
                # Cut to clipboard
                emit_signal("text_copied", get_selected_text())
                delete_selection()
        KEY_V:
            if event.ctrl:
                # Paste from clipboard (would be implemented by engine)
                emit_signal("paste_requested")
        KEY_ENTER, KEY_KP_ENTER:
            emit_signal("text_submitted", text)
        _:
            # Regular character input
            if event.unicode > 0 and event.unicode < 127:  # Printable ASCII
                var char = char(event.unicode)
                if not secret or char.is_valid_identifier() or char == " ":
                    insert_text_at_cursor(char)

# Cursor movement functions
func _move_cursor_left():
    if _cursor_position > 0:
        _cursor_position -= 1
        _clear_selection()
        _update_scroll()
        _reset_cursor_blink()

func _move_cursor_right():
    if _cursor_position < text.length():
        _cursor_position += 1
        _clear_selection()
        _update_scroll()
        _reset_cursor_blink()

func _move_cursor_to_start():
    _cursor_position = 0
    _clear_selection()
    _update_scroll()
    _reset_cursor_blink()

func _move_cursor_to_end():
    _cursor_position = text.length()
    _clear_selection()
    _update_scroll()
    _reset_cursor_blink()

# Selection extension functions
func _extend_selection_left():
    if not selecting_enabled:
        return
    
    if not has_selection():
        _selection_start = _cursor_position
        _selection_end = _cursor_position
    
    if _cursor_position > 0:
        _cursor_position -= 1
        if _cursor_position < _selection_start:
            _selection_start = _cursor_position
        else:
            _selection_end = _cursor_position
    
    _update_scroll()
    _reset_cursor_blink()

func _extend_selection_right():
    if not selecting_enabled:
        return
    
    if not has_selection():
        _selection_start = _cursor_position
        _selection_end = _cursor_position
    
    if _cursor_position < text.length():
        _cursor_position += 1
        if _cursor_position > _selection_end:
            _selection_end = _cursor_position
        else:
            _selection_start = _cursor_position
    
    _update_scroll()
    _reset_cursor_blink()

# Signals
signal text_changed(new_text: String)  # Emitted when text changes
signal text_submitted(text: String)  # Emitted when Enter is pressed
signal text_copied(text: String)  # Emitted when text is copied
signal paste_requested  # Emitted when paste is requested
