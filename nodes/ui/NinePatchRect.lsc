# NinePatchRect Node - UI node that displays a texture using 9-patch/9-slice scaling
# Allows textures to be scaled without distorting corners and edges
extends Control

# Texture Properties
export_group("Texture")
export var texture: Texture = null  # Main texture resource

# Patch Margins (define the 9-patch regions)
export_group("Patch Margins")
export var patch_margin_left: int = 0  # Left edge width in pixels
export var patch_margin_top: int = 0  # Top edge height in pixels
export var patch_margin_right: int = 0  # Right edge width in pixels
export var patch_margin_bottom: int = 0  # Bottom edge height in pixels

# Draw Properties
export_group("Draw Properties")
export var draw_center: bool = true  # Whether to draw the center patch
export var region_rect: Rect2 = Rect2(0, 0, 0, 0)  # Source region in texture (0,0,0,0 = use full texture)

# Axis Stretch Modes
export_group("Axis Stretch")
export var axis_stretch_horizontal: String = "stretch"  # How to stretch horizontal edges
export var axis_stretch_vertical: String = "stretch"  # How to stretch vertical edges

# Modulation
export_group("Modulation")
export var modulate: Color = Color(1.0, 1.0, 1.0, 1.0)  # Color modulation

# Stretch mode constants
const STRETCH_STRETCH = "stretch"  # Stretch the texture
const STRETCH_TILE = "tile"  # Tile the texture
const STRETCH_TILE_FIT = "tile_fit"  # Tile and fit to size

# Internal variables
var _texture_size: Vector2 = Vector2.ZERO
var _effective_region: Rect2 = Rect2.ZERO

# Called when the node enters the scene tree for the first time
func _ready():
    super._ready()
    
    # Set default size if not specified
    if rect_size == Vector2.ZERO:
        rect_size = Vector2(100, 100)
    
    # Update texture info
    _update_texture_info()
    
    # Connect signals
    connect("resized", self, "_on_resized")

# Called every frame. 'delta' is the elapsed time since the previous frame
func _process(delta: float):
    pass

# Handle resize events
func _on_resized():
    _update_texture_info()
    emit_signal("appearance_changed")

# Set the texture
func set_texture(new_texture: Texture):
    texture = new_texture
    _update_texture_info()
    emit_signal("appearance_changed")

# Get the texture
func get_texture() -> Texture:
    return texture

# Set patch margins
func set_patch_margins(left: int, top: int, right: int, bottom: int):
    patch_margin_left = max(0, left)
    patch_margin_top = max(0, top)
    patch_margin_right = max(0, right)
    patch_margin_bottom = max(0, bottom)
    _update_texture_info()
    emit_signal("appearance_changed")

# Get patch margins as array [left, top, right, bottom]
func get_patch_margins() -> Array:
    return [patch_margin_left, patch_margin_top, patch_margin_right, patch_margin_bottom]

# Set uniform patch margins
func set_uniform_patch_margins(margin: int):
    set_patch_margins(margin, margin, margin, margin)

# Set horizontal patch margins
func set_horizontal_patch_margins(margin: int):
    set_patch_margins(margin, patch_margin_top, margin, patch_margin_bottom)

# Set vertical patch margins
func set_vertical_patch_margins(margin: int):
    set_patch_margins(patch_margin_left, margin, patch_margin_right, margin)

# Set region rect
func set_region_rect(rect: Rect2):
    region_rect = rect
    _update_texture_info()
    emit_signal("appearance_changed")

# Get region rect
func get_region_rect() -> Rect2:
    return region_rect

# Set draw center
func set_draw_center(enabled: bool):
    draw_center = enabled
    emit_signal("appearance_changed")

# Get draw center
func get_draw_center() -> bool:
    return draw_center

# Set horizontal axis stretch mode
func set_axis_stretch_horizontal(mode: String):
    if is_valid_stretch_mode(mode):
        axis_stretch_horizontal = mode
        emit_signal("appearance_changed")
    else:
        print("Warning: Invalid horizontal stretch mode: " + mode)

# Get horizontal axis stretch mode
func get_axis_stretch_horizontal() -> String:
    return axis_stretch_horizontal

# Set vertical axis stretch mode
func set_axis_stretch_vertical(mode: String):
    if is_valid_stretch_mode(mode):
        axis_stretch_vertical = mode
        emit_signal("appearance_changed")
    else:
        print("Warning: Invalid vertical stretch mode: " + mode)

# Get vertical axis stretch mode
func get_axis_stretch_vertical() -> String:
    return axis_stretch_vertical

# Check if stretch mode is valid
func is_valid_stretch_mode(mode: String) -> bool:
    return mode in [STRETCH_STRETCH, STRETCH_TILE, STRETCH_TILE_FIT]

# Set modulate color
func set_modulate(color: Color):
    modulate = color
    emit_signal("appearance_changed")

# Get modulate color
func get_modulate() -> Color:
    return modulate

# Update texture information
func _update_texture_info():
    if not texture:
        _texture_size = Vector2.ZERO
        _effective_region = Rect2.ZERO
        return
    
    _texture_size = texture.get_size()
    
    # Determine effective region
    if region_rect.size == Vector2.ZERO:
        _effective_region = Rect2(Vector2.ZERO, _texture_size)
    else:
        _effective_region = region_rect

# Get the 9 patch regions for rendering
func get_patch_regions() -> Dictionary:
    if not texture or _effective_region.size == Vector2.ZERO:
        return {}
    
    var regions = {}
    var tex_w = _effective_region.size.x
    var tex_h = _effective_region.size.y
    var tex_x = _effective_region.position.x
    var tex_y = _effective_region.position.y
    
    # Calculate patch sizes
    var left = patch_margin_left
    var top = patch_margin_top
    var right = patch_margin_right
    var bottom = patch_margin_bottom
    
    var center_w = tex_w - left - right
    var center_h = tex_h - top - bottom
    
    # Source regions in texture
    regions["top_left"] = Rect2(tex_x, tex_y, left, top)
    regions["top_center"] = Rect2(tex_x + left, tex_y, center_w, top)
    regions["top_right"] = Rect2(tex_x + left + center_w, tex_y, right, top)
    
    regions["middle_left"] = Rect2(tex_x, tex_y + top, left, center_h)
    regions["middle_center"] = Rect2(tex_x + left, tex_y + top, center_w, center_h)
    regions["middle_right"] = Rect2(tex_x + left + center_w, tex_y + top, right, center_h)
    
    regions["bottom_left"] = Rect2(tex_x, tex_y + top + center_h, left, bottom)
    regions["bottom_center"] = Rect2(tex_x + left, tex_y + top + center_h, center_w, bottom)
    regions["bottom_right"] = Rect2(tex_x + left + center_w, tex_y + top + center_h, right, bottom)
    
    return regions

# Get the 9 destination rectangles for drawing
func get_draw_regions() -> Dictionary:
    var regions = {}
    var w = rect_size.x
    var h = rect_size.y
    
    # Calculate destination sizes
    var left = patch_margin_left
    var top = patch_margin_top
    var right = patch_margin_right
    var bottom = patch_margin_bottom
    
    var center_w = w - left - right
    var center_h = h - top - bottom
    
    # Destination regions on screen
    regions["top_left"] = Rect2(0, 0, left, top)
    regions["top_center"] = Rect2(left, 0, center_w, top)
    regions["top_right"] = Rect2(left + center_w, 0, right, top)
    
    regions["middle_left"] = Rect2(0, top, left, center_h)
    regions["middle_center"] = Rect2(left, top, center_w, center_h)
    regions["middle_right"] = Rect2(left + center_w, top, right, center_h)
    
    regions["bottom_left"] = Rect2(0, top + center_h, left, bottom)
    regions["bottom_center"] = Rect2(left, top + center_h, center_w, bottom)
    regions["bottom_right"] = Rect2(left + center_w, top + center_h, right, bottom)
    
    return regions

# Get minimum size based on patch margins
func get_minimum_size() -> Vector2:
    return Vector2(
        patch_margin_left + patch_margin_right,
        patch_margin_top + patch_margin_bottom
    )

# Fit to texture size
func fit_to_texture():
    if texture:
        var tex_size = texture.get_size()
        if region_rect.size != Vector2.ZERO:
            tex_size = region_rect.size
        rect_size = tex_size
        emit_signal("appearance_changed")

# Auto-detect patch margins from texture (looks for transparent pixels)
func auto_detect_patch_margins():
    if not texture:
        return
    
    # This would require texture pixel access in a real implementation
    # For now, set reasonable defaults
    var tex_size = texture.get_size()
    if region_rect.size != Vector2.ZERO:
        tex_size = region_rect.size
    
    # Use 1/8 of texture size as default margins
    var margin = int(min(tex_size.x, tex_size.y) / 8)
    set_patch_margins(margin, margin, margin, margin)

# Convenience methods for stretch modes
func stretch_edges():
    set_axis_stretch_horizontal(STRETCH_STRETCH)
    set_axis_stretch_vertical(STRETCH_STRETCH)

func tile_edges():
    set_axis_stretch_horizontal(STRETCH_TILE)
    set_axis_stretch_vertical(STRETCH_TILE)

func tile_fit_edges():
    set_axis_stretch_horizontal(STRETCH_TILE_FIT)
    set_axis_stretch_vertical(STRETCH_TILE_FIT)

# Convenience methods for common 9-patch setups
func setup_button_patch(margin: int = 8):
    """Setup for button-style 9-patch"""
    set_uniform_patch_margins(margin)
    stretch_edges()
    set_draw_center(true)

func setup_border_patch(border_size: int = 4):
    """Setup for border-style 9-patch"""
    set_uniform_patch_margins(border_size)
    stretch_edges()
    set_draw_center(false)

func setup_panel_patch(margin: int = 12):
    """Setup for panel-style 9-patch"""
    set_uniform_patch_margins(margin)
    stretch_edges()
    set_draw_center(true)

func setup_frame_patch(frame_width: int = 6):
    """Setup for frame-style 9-patch"""
    set_uniform_patch_margins(frame_width)
    tile_edges()
    set_draw_center(true)

# Check if point is inside the control
func has_point(point: Vector2) -> bool:
    return Rect2(Vector2.ZERO, rect_size).has_point(point)

# Get effective drawing rectangle
func get_draw_rect() -> Rect2:
    return Rect2(Vector2.ZERO, rect_size)

# Load texture from path
func load_texture_from_path(path: String):
    # This would be implemented by the engine's resource system
    emit_signal("texture_load_requested", path)

# Signals
signal appearance_changed  # Emitted when visual properties change
signal texture_load_requested(path)  # Emitted when texture loading is requested
