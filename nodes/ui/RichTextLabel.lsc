# RichTextLabel Node - Advanced text display with rich formatting support
# Supports BBCode markup, scrolling, text effects, and advanced text rendering
extends Control

# Text Content
export_group("Text Content")
export var text: String = ""  # Raw text with BBCode markup
export var bbcode_enabled: bool = true  # Enable BBCode parsing
export var bbcode_text: String = ""  # Processed BBCode text (read-only when bbcode_enabled)

# Text Behavior
export_group("Text Behavior")
export var fit_content_height: bool = false  # Auto-resize height to fit content
export var scroll_active: bool = true  # Enable scrolling for overflow content
export var scroll_following: bool = false  # Auto-scroll to bottom when content changes
export var selection_enabled: bool = false  # Allow text selection with mouse

# Text Appearance
export_group("Text Appearance")
export var visible_characters: int = -1  # Number of visible characters (-1 = all)
export var percent_visible: float = 1.0  # Percentage of text visible (0.0-1.0)

# Default Font Properties
export_group("Default Font")
export var default_font: Resource = null  # Default font resource
export var default_font_size: int = 14  # Default font size
export var default_color: Color = Color(1.0, 1.0, 1.0, 1.0)  # Default text color

# Text Processing
export_group("Text Processing")
export var tab_size: int = 4  # Tab character width in spaces
export var text_direction: String = "auto"  # "auto", "ltr", "rtl"
export var language: String = ""  # Language code for text processing

# Scrolling
export_group("Scrolling")
export var scroll_position: Vector2 = Vector2(0.0, 0.0)  # Current scroll position
export var scroll_speed: float = 1.0  # Scroll speed multiplier

# Style Properties
export_group("Style")
export var background_color: Color = Color(0.0, 0.0, 0.0, 0.0)  # Background color (transparent by default)
export var border_color: Color = Color(0.5, 0.5, 0.5, 1.0)  # Border color
export var border_width: float = 0.0  # Border thickness
export var corner_radius: float = 0.0  # Corner radius for rounded borders

# Internal variables
var _parsed_text: String = ""
var _text_lines: Array = []
var _cached_text_size: Vector2 = Vector2.ZERO
var _scroll_bar_visible: bool = false
var _selection_start: int = -1
var _selection_end: int = -1

# BBCode tag constants
const BBCODE_BOLD = "b"
const BBCODE_ITALIC = "i"
const BBCODE_UNDERLINE = "u"
const BBCODE_STRIKETHROUGH = "s"
const BBCODE_COLOR = "color"
const BBCODE_SIZE = "size"
const BBCODE_FONT = "font"
const BBCODE_URL = "url"
const BBCODE_IMG = "img"
const BBCODE_CENTER = "center"
const BBCODE_RIGHT = "right"
const BBCODE_FILL = "fill"
const BBCODE_INDENT = "indent"
const BBCODE_TABLE = "table"
const BBCODE_CELL = "cell"

# Called when the node enters the scene tree for the first time
func _ready():
    super._ready()
    
    # Set default size if not specified
    if rect_size == Vector2.ZERO:
        rect_size = Vector2(200, 100)
    
    # Parse initial text
    _parse_text()
    
    # Connect signals
    connect("resized", self, "_on_resized")

# Called every frame. 'delta' is the elapsed time since the previous frame
func _process(delta: float):
    pass

# Handle resize events
func _on_resized():
    _parse_text()
    _update_scroll_bars()

# Set the text content
func set_text(new_text: String):
    if text != new_text:
        text = new_text
        _parse_text()
        emit_signal("text_changed")

# Get the text content
func get_text() -> String:
    return text

# Set BBCode text (when bbcode_enabled is false)
func set_bbcode_text(new_bbcode_text: String):
    if not bbcode_enabled:
        bbcode_text = new_bbcode_text
        _parse_text()
        emit_signal("text_changed")

# Get BBCode text
func get_bbcode_text() -> String:
    if bbcode_enabled:
        return text
    else:
        return bbcode_text

# Enable or disable BBCode parsing
func set_bbcode_enabled(enabled: bool):
    if bbcode_enabled != enabled:
        bbcode_enabled = enabled
        _parse_text()
        emit_signal("bbcode_toggled", enabled)

# Get BBCode enabled state
func is_bbcode_enabled() -> bool:
    return bbcode_enabled

# Set visible characters count
func set_visible_characters(count: int):
    visible_characters = count
    _update_visible_text()
    emit_signal("visibility_changed")

# Get visible characters count
func get_visible_characters() -> int:
    return visible_characters

# Set visible percentage
func set_percent_visible(percent: float):
    percent_visible = clamp(percent, 0.0, 1.0)
    _update_visible_text()
    emit_signal("visibility_changed")

# Get visible percentage
func get_percent_visible() -> float:
    return percent_visible

# Append text to the end
func append_text(new_text: String):
    text += new_text
    _parse_text()
    
    if scroll_following:
        scroll_to_bottom()
    
    emit_signal("text_changed")

# Append BBCode text to the end
func append_bbcode_text(bbcode: String):
    if bbcode_enabled:
        append_text(bbcode)
    else:
        bbcode_text += bbcode
        _parse_text()
        
        if scroll_following:
            scroll_to_bottom()
        
        emit_signal("text_changed")

# Clear all text
func clear():
    text = ""
    bbcode_text = ""
    _parsed_text = ""
    _text_lines.clear()
    _cached_text_size = Vector2.ZERO
    scroll_position = Vector2.ZERO
    emit_signal("text_changed")

# Add image to text
func add_image(texture: Texture, width: int = -1, height: int = -1):
    if not texture:
        return
    
    var img_tag = "[img"
    if width > 0:
        img_tag += "=" + str(width)
        if height > 0:
            img_tag += "x" + str(height)
    img_tag += "]" + texture.resource_path + "[/img]"
    
    append_bbcode_text(img_tag)

# Add text with formatting
func add_text(new_text: String, color: Color = Color.WHITE, size: int = -1, bold: bool = false, italic: bool = false):
    var formatted_text = new_text
    
    if bbcode_enabled:
        if bold:
            formatted_text = "[b]" + formatted_text + "[/b]"
        if italic:
            formatted_text = "[i]" + formatted_text + "[/i]"
        if size > 0:
            formatted_text = "[size=" + str(size) + "]" + formatted_text + "[/size]"
        if color != Color.WHITE:
            formatted_text = "[color=" + color.to_html() + "]" + formatted_text + "[/color]"
    
    append_text(formatted_text)

# Scroll to top
func scroll_to_top():
    scroll_position.y = 0.0
    emit_signal("scroll_changed")

# Scroll to bottom
func scroll_to_bottom():
    var max_scroll = max(0.0, _cached_text_size.y - rect_size.y)
    scroll_position.y = max_scroll
    emit_signal("scroll_changed")

# Scroll by amount
func scroll_by(amount: Vector2):
    var old_position = scroll_position
    scroll_position += amount * scroll_speed
    _clamp_scroll_position()
    
    if scroll_position != old_position:
        emit_signal("scroll_changed")

# Set scroll position
func set_scroll_position(pos: Vector2):
    scroll_position = pos
    _clamp_scroll_position()
    emit_signal("scroll_changed")

# Get scroll position
func get_scroll_position() -> Vector2:
    return scroll_position

# Enable/disable text selection
func set_selection_enabled(enabled: bool):
    selection_enabled = enabled
    if not enabled:
        _clear_selection()

# Get selection enabled state
func is_selection_enabled() -> bool:
    return selection_enabled

# Get selected text
func get_selected_text() -> String:
    if _selection_start < 0 or _selection_end < 0:
        return ""
    
    var start = min(_selection_start, _selection_end)
    var end = max(_selection_start, _selection_end)
    
    return _parsed_text.substr(start, end - start)

# Select all text
func select_all():
    if selection_enabled and _parsed_text.length() > 0:
        _selection_start = 0
        _selection_end = _parsed_text.length()
        emit_signal("selection_changed")

# Clear selection
func _clear_selection():
    _selection_start = -1
    _selection_end = -1
    emit_signal("selection_changed")

# Parse text and handle BBCode
func _parse_text():
    if bbcode_enabled:
        _parsed_text = _parse_bbcode(text)
    else:
        _parsed_text = bbcode_text if bbcode_text != "" else text
    
    _update_text_layout()
    _update_visible_text()

# Parse BBCode markup (simplified implementation)
func _parse_bbcode(bbcode_text: String) -> String:
    # This is a simplified BBCode parser
    # In a full implementation, this would handle all BBCode tags properly
    var result = bbcode_text
    
    # Remove simple tags for now (keeping text content)
    result = result.replace("[b]", "").replace("[/b]", "")
    result = result.replace("[i]", "").replace("[/i]", "")
    result = result.replace("[u]", "").replace("[/u]", "")
    result = result.replace("[s]", "").replace("[/s]", "")
    result = result.replace("[center]", "").replace("[/center]", "")
    result = result.replace("[right]", "").replace("[/right]", "")
    
    # Handle color tags
    var color_regex = RegEx.new()
    color_regex.compile("\\[color=[^\\]]+\\]")
    result = color_regex.sub(result, "", true)
    result = result.replace("[/color]", "")
    
    # Handle size tags
    var size_regex = RegEx.new()
    size_regex.compile("\\[size=[^\\]]+\\]")
    result = size_regex.sub(result, "", true)
    result = result.replace("[/size]", "")
    
    return result

# Update text layout
func _update_text_layout():
    _text_lines.clear()
    
    if _parsed_text.empty():
        _cached_text_size = Vector2.ZERO
        return
    
    # Simple text layout - split by newlines
    var lines = _parsed_text.split("\n")
    
    # TODO: Implement word wrapping based on rect_size.x
    _text_lines = lines
    
    # Calculate text size (simplified)
    var line_height = default_font_size * 1.2  # Approximate line height
    var max_width = 0.0
    
    for line in _text_lines:
        # Approximate character width
        var line_width = line.length() * default_font_size * 0.6
        max_width = max(max_width, line_width)
    
    _cached_text_size = Vector2(max_width, _text_lines.size() * line_height)
    
    # Auto-resize height if enabled
    if fit_content_height:
        rect_size.y = _cached_text_size.y

# Update visible text based on visible_characters and percent_visible
func _update_visible_text():
    # This would be used by the renderer to determine what text to actually display
    pass

# Update scroll bars visibility and position
func _update_scroll_bars():
    _scroll_bar_visible = _cached_text_size.y > rect_size.y
    _clamp_scroll_position()

# Clamp scroll position to valid range
func _clamp_scroll_position():
    var max_scroll_x = max(0.0, _cached_text_size.x - rect_size.x)
    var max_scroll_y = max(0.0, _cached_text_size.y - rect_size.y)
    
    scroll_position.x = clamp(scroll_position.x, 0.0, max_scroll_x)
    scroll_position.y = clamp(scroll_position.y, 0.0, max_scroll_y)

# Get the calculated text size
func get_text_size() -> Vector2:
    return _cached_text_size

# Get content rectangle (area available for text)
func get_content_rect() -> Rect2:
    return Rect2(Vector2.ZERO, rect_size)

# Check if scroll bars are needed
func is_scroll_bar_visible() -> bool:
    return _scroll_bar_visible

# Convenience methods for common BBCode
func push_bold():
    if bbcode_enabled:
        append_bbcode_text("[b]")

func pop_bold():
    if bbcode_enabled:
        append_bbcode_text("[/b]")

func push_italic():
    if bbcode_enabled:
        append_bbcode_text("[i]")

func pop_italic():
    if bbcode_enabled:
        append_bbcode_text("[/i]")

func push_color(color: Color):
    if bbcode_enabled:
        append_bbcode_text("[color=" + color.to_html() + "]")

func pop_color():
    if bbcode_enabled:
        append_bbcode_text("[/color]")

func push_size(size: int):
    if bbcode_enabled:
        append_bbcode_text("[size=" + str(size) + "]")

func pop_size():
    if bbcode_enabled:
        append_bbcode_text("[/size]")

func newline():
    append_text("\n")

# Signals
signal text_changed  # Emitted when text content changes
signal bbcode_toggled(enabled)  # Emitted when BBCode is enabled/disabled
signal visibility_changed  # Emitted when visible characters/percent changes
signal scroll_changed  # Emitted when scroll position changes
signal selection_changed  # Emitted when text selection changes
