# TextureRect Node - UI node that displays a texture with various stretch modes
# Equivalent to Godot's TextureRect with full stretch mode support
extends Control

# Texture Properties
export_group("Texture")
export var texture: path = ""  # Texture resource to display (uses file browser)

# Stretch Properties
export_group("Stretch")
export var stretch_mode: String = "stretch"  # How to stretch the texture
export var expand: bool = false  # Whether to expand beyond texture size

# Flip Properties
export_group("Flip")
export var flip_h: bool = false  # Flip horizontally
export var flip_v: bool = false  # Flip vertically

# Stretch mode constants (matching Godot's TextureRect)
const STRETCH_STRETCH = "stretch"  # Stretch to fill the rect
const STRETCH_TILE = "tile"  # Tile the texture
const STRETCH_KEEP = "keep"  # Keep original size
const STRETCH_KEEP_CENTERED = "keep_centered"  # Keep original size, centered
const STRETCH_KEEP_ASPECT = "keep_aspect"  # Keep aspect ratio, fit inside
const STRETCH_KEEP_ASPECT_CENTERED = "keep_aspect_centered"  # Keep aspect ratio, centered
const STRETCH_KEEP_ASPECT_COVERED = "keep_aspect_covered"  # Keep aspect ratio, cover entire rect

# Called when the node enters the scene tree for the first time
func _ready():
    super._ready()
    
    # Set default size if not specified
    if rect_size == Vector2.ZERO:
        rect_size = Vector2(100, 100)

# Called every frame. 'delta' is the elapsed time since the previous frame
func _process(delta: float):
    pass

# Set the texture
func set_texture(new_texture: Texture):
    texture = new_texture
    
    # Auto-resize to texture size if expand is false and size is default
    if texture and not expand and rect_size == Vector2(100, 100):
        rect_size = texture.get_size()
    
    # Emit signal for renderer update
    emit_signal("appearance_changed")

# Get the texture
func get_texture() -> Texture:
    return texture

# Set stretch mode
func set_stretch_mode(mode: String):
    if is_valid_stretch_mode(mode):
        stretch_mode = mode
        emit_signal("appearance_changed")
    else:
        print("Warning: Invalid stretch mode: " + mode)

# Get stretch mode
func get_stretch_mode() -> String:
    return stretch_mode

# Set expand property
func set_expand(should_expand: bool):
    expand = should_expand
    emit_signal("appearance_changed")

# Get expand property
func get_expand() -> bool:
    return expand

# Set horizontal flip
func set_flip_h(flip: bool):
    flip_h = flip
    emit_signal("appearance_changed")

# Get horizontal flip
func get_flip_h() -> bool:
    return flip_h

# Set vertical flip
func set_flip_v(flip: bool):
    flip_v = flip
    emit_signal("appearance_changed")

# Get vertical flip
func get_flip_v() -> bool:
    return flip_v

# Check if stretch mode is valid
func is_valid_stretch_mode(mode: String) -> bool:
    return mode in [
        STRETCH_STRETCH,
        STRETCH_TILE,
        STRETCH_KEEP,
        STRETCH_KEEP_CENTERED,
        STRETCH_KEEP_ASPECT,
        STRETCH_KEEP_ASPECT_CENTERED,
        STRETCH_KEEP_ASPECT_COVERED
    ]

# Get the effective rect for drawing the texture
func get_draw_rect() -> Rect2:
    if not texture or texture == "":
        return Rect2(position, rect_size)

    var texture_size = get_texture_size()
    var control_size = rect_size
    
    match stretch_mode:
        STRETCH_STRETCH:
            return Rect2(position, control_size)
        
        STRETCH_KEEP:
            return Rect2(position, texture_size)
        
        STRETCH_KEEP_CENTERED:
            var offset = (control_size - texture_size) * 0.5
            return Rect2(position + offset, texture_size)
        
        STRETCH_KEEP_ASPECT:
            var scale_factor = min(control_size.x / texture_size.x, control_size.y / texture_size.y)
            var scaled_size = texture_size * scale_factor
            return Rect2(position, scaled_size)
        
        STRETCH_KEEP_ASPECT_CENTERED:
            var scale_factor = min(control_size.x / texture_size.x, control_size.y / texture_size.y)
            var scaled_size = texture_size * scale_factor
            var offset = (control_size - scaled_size) * 0.5
            return Rect2(position + offset, scaled_size)
        
        STRETCH_KEEP_ASPECT_COVERED:
            var scale_factor = max(control_size.x / texture_size.x, control_size.y / texture_size.y)
            var scaled_size = texture_size * scale_factor
            var offset = (control_size - scaled_size) * 0.5
            return Rect2(position + offset, scaled_size)
        
        STRETCH_TILE:
            return Rect2(position, control_size)
        
        _:
            return Rect2(position, control_size)

# Get texture size
func get_texture_size() -> Vector2:
    if texture and texture != "":
        # For now, return a default size since we're using path strings
        # In a full implementation, this would load the texture and get its size
        return Vector2(100, 100)
    return Vector2.ZERO

# Check if texture is loaded
func has_texture() -> bool:
    return texture != "" and texture != null

# Clear the texture
func clear_texture():
    set_texture(null)

# Load texture from path
func load_texture_from_path(path: String):
    # This would be implemented by the engine's resource system
    # For now, just emit a signal
    emit_signal("texture_load_requested", path)

# Get UV coordinates for a point (useful for texture sampling)
func get_uv_at_point(point: Vector2) -> Vector2:
    if not texture:
        return Vector2.ZERO
    
    var draw_rect = get_draw_rect()
    var local_point = point - draw_rect.position
    
    # Handle flipping
    var uv = Vector2(
        local_point.x / draw_rect.size.x,
        local_point.y / draw_rect.size.y
    )
    
    if flip_h:
        uv.x = 1.0 - uv.x
    if flip_v:
        uv.y = 1.0 - uv.y
    
    return uv

# Check if a point is inside the texture rect
func has_point(point: Vector2) -> bool:
    var draw_rect = get_draw_rect()
    return draw_rect.has_point(point)

# Fit texture to control size (changes stretch mode)
func fit_texture_to_size():
    set_stretch_mode(STRETCH_STRETCH)

# Keep texture original size
func keep_texture_size():
    set_stretch_mode(STRETCH_KEEP)

# Center texture in control
func center_texture():
    set_stretch_mode(STRETCH_KEEP_CENTERED)

# Keep aspect ratio and fit inside
func fit_texture_aspect():
    set_stretch_mode(STRETCH_KEEP_ASPECT_CENTERED)

# Keep aspect ratio and cover entire rect
func cover_texture_aspect():
    set_stretch_mode(STRETCH_KEEP_ASPECT_COVERED)

# Tile the texture
func tile_texture():
    set_stretch_mode(STRETCH_TILE)

# Convenience methods for common operations
func set_texture_and_resize(new_texture: Texture):
    set_texture(new_texture)
    if new_texture:
        rect_size = new_texture.get_size()

func set_texture_and_fit(new_texture: Texture):
    set_texture(new_texture)
    fit_texture_to_size()

# Signals
signal appearance_changed  # Emitted when visual properties change
signal texture_changed(new_texture: Texture)  # Emitted when texture changes
signal texture_load_requested(path: String)  # Emitted when texture load is requested
