# PlayerController - Top-down player controller prefab
# Provides easy-to-use player movement with animation hooks and input handling
extends KinematicBody2D

# Movement Settings
export_group("Movement")
export var movement_type: String = "8_direction"  # "4_direction", "8_direction"
export var speed: float = 200.0  # Movement speed in pixels/second
export var acceleration: float = 1000.0  # Acceleration when starting to move
export var friction: float = 1000.0  # Deceleration when stopping

# Input Settings
export_group("Input")
export var use_wasd: bool = true  # Enable WASD keys
export var use_arrows: bool = true  # Enable arrow keys
export var use_gamepad: bool = true  # Enable gamepad input
export var interact_key: String = "E"  # Interaction key
export var run_key: String = "Shift"  # Run modifier key

# Animation Settings
export_group("Animation")
export var enable_animations: bool = true  # Enable sprite animations
export var idle_animation: String = "idle"  # Base idle animation name
export var walk_animation: String = "walk"  # Base walk animation name
export var run_animation: String = "run"  # Base run animation name

# Animation Direction Suffixes (will be appended to base animation names)
export_group("Animation Directions")
export var down_suffix: String = "_down"  # Down direction suffix
export var up_suffix: String = "_up"  # Up direction suffix
export var left_suffix: String = "_left"  # Left direction suffix
export var right_suffix: String = "_right"  # Right direction suffix
export var down_left_suffix: String = "_down_left"  # Down-left diagonal (8-dir only)
export var down_right_suffix: String = "_down_right"  # Down-right diagonal (8-dir only)
export var up_left_suffix: String = "_up_left"  # Up-left diagonal (8-dir only)
export var up_right_suffix: String = "_up_right"  # Up-right diagonal (8-dir only)

# Internal properties
var velocity: Vector2 = Vector2.ZERO
var last_direction: Vector2 = Vector2.DOWN  # Default facing direction
var is_moving: bool = false
var is_running: bool = false
var sprite_node: Node2D = null
var interaction_area: Node2D = null

# Input state
var input_vector: Vector2 = Vector2.ZERO

# Called when the node enters the scene tree
func _ready():
    # Find child nodes
    sprite_node = get_node("Sprite")
    interaction_area = get_node("InteractionArea")
    
    # Setup interaction area signals
    if interaction_area:
        interaction_area.connect("body_entered", self, "_on_interaction_area_entered")
        interaction_area.connect("body_exited", self, "_on_interaction_area_exited")
    
    # Set initial animation
    if enable_animations and sprite_node:
        _play_animation("idle", _get_direction_suffix(last_direction))

# Called every frame
func _process(delta: float):
    # Handle input
    _handle_input()
    
    # Update movement
    _update_movement(delta)
    
    # Update animations
    if enable_animations:
        _update_animations()

# Handle player input
func _handle_input():
    input_vector = Vector2.ZERO

    # WASD input (simplified for now - will be enhanced with proper input system)
    if use_wasd:
        # For now, use simple key detection (this will be replaced with proper input system)
        # Left/A
        if get_global_input("left") or get_global_input("a"):
            input_vector.x -= 1
        # Right/D
        if get_global_input("right") or get_global_input("d"):
            input_vector.x += 1
        # Up/W
        if get_global_input("up") or get_global_input("w"):
            input_vector.y -= 1
        # Down/S
        if get_global_input("down") or get_global_input("s"):
            input_vector.y += 1

    # Arrow key input
    if use_arrows:
        if get_global_input("left"):
            input_vector.x -= 1
        if get_global_input("right"):
            input_vector.x += 1
        if get_global_input("up"):
            input_vector.y -= 1
        if get_global_input("down"):
            input_vector.y += 1

    # Normalize diagonal movement for 8-direction
    if movement_type == "8_direction" and input_vector.length() > 1:
        input_vector = input_vector.normalized()

    # Restrict to 4 directions if needed
    elif movement_type == "4_direction":
        if abs(input_vector.x) > abs(input_vector.y):
            input_vector.y = 0
        else:
            input_vector.x = 0
        if input_vector.length() > 0:
            input_vector = input_vector.normalized()

    # Check for run modifier (simplified)
    is_running = get_global_input("shift")

    # Handle interaction (simplified)
    if get_global_input("e") or get_global_input("space"):
        _handle_interaction()

# Input helper that connects to the game engine's input system
func get_global_input(key: String) -> bool:
    # Use the LSC runtime's input system to check key states
    # This connects to the game runner's input handling

    # Map key names to arcade key constants
    var arcade_key = _map_key_to_arcade(key)
    if arcade_key != -1:
        return is_key_pressed(arcade_key)

    return false

# Map string key names to arcade key constants
func _map_key_to_arcade(key: String) -> int:
    # Map common key names to their arcade equivalents
    match key:
        # Arrow keys
        "left":
            return 65361  # arcade.key.LEFT
        "right":
            return 65363  # arcade.key.RIGHT
        "up":
            return 65362  # arcade.key.UP
        "down":
            return 65364  # arcade.key.DOWN
        # WASD keys
        "a":
            return 97  # arcade.key.A
        "d":
            return 100  # arcade.key.D
        "w":
            return 119  # arcade.key.W
        "s":
            return 115  # arcade.key.S
        # Other keys
        "shift":
            return 65505  # arcade.key.LSHIFT
        "e":
            return 101  # arcade.key.E
        "space":
            return 32  # arcade.key.SPACE
        _:
            return -1

# Get current time from LSC runtime
func get_time() -> float:
    # Use the LSC runtime's time system
    return get_runtime_time()

# Update movement physics
func _update_movement(delta: float):
    var target_velocity = Vector2.ZERO
    
    if input_vector.length() > 0:
        # Calculate target speed
        var current_speed = speed
        if is_running:
            current_speed *= 1.5  # 50% speed boost when running
        
        target_velocity = input_vector * current_speed
        last_direction = input_vector
        is_moving = true
    else:
        is_moving = false
    
    # Apply acceleration/friction
    if is_moving:
        velocity = velocity.move_toward(target_velocity, acceleration * delta)
    else:
        velocity = velocity.move_toward(Vector2.ZERO, friction * delta)
    
    # Move the character
    velocity = move_and_slide(velocity)

# Update sprite animations based on movement
func _update_animations():
    if not sprite_node:
        return
    
    var animation_name = ""
    var direction_suffix = _get_direction_suffix(last_direction)
    
    # Determine animation type
    if is_moving:
        if is_running:
            animation_name = run_animation
        else:
            animation_name = walk_animation
    else:
        animation_name = idle_animation
    
    # Play the animation with direction
    _play_animation(animation_name, direction_suffix)

# Get direction suffix for animations
func _get_direction_suffix(direction: Vector2) -> String:
    if movement_type == "4_direction":
        # 4-direction movement
        if abs(direction.x) > abs(direction.y):
            return right_suffix if direction.x > 0 else left_suffix
        else:
            return down_suffix if direction.y > 0 else up_suffix
    
    else:
        # 8-direction movement
        var angle = direction.angle()
        
        # Convert angle to degrees for easier comparison
        var degrees = rad2deg(angle)
        if degrees < 0:
            degrees += 360
        
        # Determine direction based on angle
        if degrees >= 337.5 or degrees < 22.5:
            return right_suffix
        elif degrees >= 22.5 and degrees < 67.5:
            return down_right_suffix
        elif degrees >= 67.5 and degrees < 112.5:
            return down_suffix
        elif degrees >= 112.5 and degrees < 157.5:
            return down_left_suffix
        elif degrees >= 157.5 and degrees < 202.5:
            return left_suffix
        elif degrees >= 202.5 and degrees < 247.5:
            return up_left_suffix
        elif degrees >= 247.5 and degrees < 292.5:
            return up_suffix
        else:  # 292.5 to 337.5
            return up_right_suffix

# Play animation with direction suffix
func _play_animation(base_name: String, direction_suffix: String):
    if not sprite_node:
        return
    
    var full_animation_name = base_name + direction_suffix
    
    # Try to play the specific directional animation
    if sprite_node.has_method("play_animation"):
        sprite_node.play_animation(full_animation_name)
    elif sprite_node.has_method("set_animation"):
        sprite_node.set_animation(full_animation_name)
    
    # Fallback: try base animation without direction
    elif sprite_node.has_method("play_animation"):
        sprite_node.play_animation(base_name)
    elif sprite_node.has_method("set_animation"):
        sprite_node.set_animation(base_name)

# Handle interaction with objects
func _handle_interaction():
    if not interaction_area:
        return
    
    # Get overlapping bodies in interaction area
    var overlapping_bodies = interaction_area.get_overlapping_bodies()
    
    for body in overlapping_bodies:
        if body != self and body.has_method("interact"):
            body.interact(self)
            break  # Interact with first available object

# Called when something enters interaction area
func _on_interaction_area_entered(body: Node2D):
    if body != self:
        # Signal that an interactable object is nearby
        emit_signal("interactable_entered", body)

# Called when something exits interaction area
func _on_interaction_area_exited(body: Node2D):
    if body != self:
        # Signal that an interactable object is no longer nearby
        emit_signal("interactable_exited", body)

# Public methods for external control

# Set movement speed
func set_movement_speed(new_speed: float):
    speed = new_speed

# Set movement type
func set_movement_type(new_type: String):
    if new_type in ["4_direction", "8_direction"]:
        movement_type = new_type

# Enable/disable input
func set_input_enabled(enabled: bool):
    if not enabled:
        input_vector = Vector2.ZERO
        velocity = Vector2.ZERO

# Get current movement direction
func get_movement_direction() -> Vector2:
    return last_direction

# Get current velocity
func get_velocity() -> Vector2:
    return velocity

# Check if player is moving
func is_player_moving() -> bool:
    return is_moving

# Check if player is running
func is_player_running() -> bool:
    return is_running

# Teleport player to position
func teleport_to(new_position: Vector2):
    position = new_position
    velocity = Vector2.ZERO

# Add knockback effect
func apply_knockback(force: Vector2, duration: float = 0.3):
    velocity += force
    # Could add temporary input disable here

# Signals
signal interactable_entered(body)  # Emitted when entering interaction range
signal interactable_exited(body)  # Emitted when leaving interaction range
signal movement_changed(direction, is_moving)  # Emitted when movement state changes
signal animation_changed(animation_name)  # Emitted when animation changes
